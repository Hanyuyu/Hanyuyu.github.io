<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://stevenhy.com</id>
    <title>stevenhy&apos;s pocket</title>
    <updated>2019-08-14T09:21:27.804Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://stevenhy.com"/>
    <link rel="self" href="http://stevenhy.com/atom.xml"/>
    <subtitle>玻璃明亮, 橘子辉煌</subtitle>
    <logo>http://stevenhy.com/images/avatar.png</logo>
    <icon>http://stevenhy.com/favicon.ico</icon>
    <rights>All rights reserved 2019, stevenhy&apos;s pocket</rights>
    <entry>
        <title type="html"><![CDATA[深入理解递归的运行机制]]></title>
        <id>http://stevenhy.com/post/9KuaIONib1</id>
        <link href="http://stevenhy.com/post/9KuaIONib1">
        </link>
        <updated>2019-08-14T04:15:52.000Z</updated>
        <summary type="html"><![CDATA[<p>🙋‍♂️这一篇主要理一理关于递归的那些事儿, 顺便给之前的LeetCode 203题做个小结.</p>
]]></summary>
        <content type="html"><![CDATA[<p>🙋‍♂️这一篇主要理一理关于递归的那些事儿, 顺便给之前的LeetCode 203题做个小结.</p>
<!-- more -->
<h2 id="引入递归">引入递归</h2>
<p>递归调用是有代价的，体现在函数调用+系统栈空间 。<br>
如果不处理那个最小的事件单元， 那么递归是不会有返回值的，<br>
递归将一直进行下去，占满系统栈空间，导致程序崩溃<br>
当然如果递归次数过多， 系统栈也会同样被占满。</p>
<p>说起递归，它的原理和我们之前讲过的栈的一个应用十分类似，就是子程序调用的过程，深入递归内部，实现过程是一样的，所以会存在系统栈这一说法。<br>
<img src="http://stevenhy.com/post-images/1565760791060.png" alt=""></p>
<p>这里提一道简单的题目，给定一个int数组，我们把数组内所有元素的和求出来.<br>
用递归的思想来解决<br>
编写的sum函数接受两个参数, arr是要计算的数组变量,l是一个索引标识, 函数的功能是计算arr中[ l,n )的元素和</p>
<pre><code class="language-java">public static void main(String[] args){
		public sum(int[] arr, int l) {
				if(l == arr.length)
						return 0;
				return arr[0] + sum(arr, l+1);
		}
}
</code></pre>
<p>我们来看一下递归函数在执行过程中的原理图<br>
<img src="http://stevenhy.com/post-images/1565759980401.png" alt=""></p>
<h2 id="深入分析">深入分析</h2>
<p>从上面的分析, 我们可以知晓递归的具体实现过程. 至于面对一个递归问题, 如何分析出解决代码, 其实也是有章可循的。🤪<br>
在这里我总结一个方法：</p>
<ul>
<li>找到最小问题单元，实现返回值。</li>
<li>把比原问题小一级的问题答案当作已知，去解决大问题。</li>
</ul>
<p>这样说起来，可能比较抽象，我来分布讲解一下：</p>
<ol>
<li>对第一步的理解，我们可以参考上面求和一题，大问题是数组中每个元素求和，就是<strong>和(arr[0]~arr[n])</strong>, 按照递归的思想，这个大问题可以转化为 <strong>arr[0]+和(arr[1]~arr[n])</strong>, 那么现在<strong>和(arr[1]~arr[n])</strong> 就成了我们的新问题，同时这个新问题就是比原问题小一级的问题，换句话说，我们只要解决了这个新问题，那原问题便可迎刃而解。为了方便之后描述，我们暂且把这个新问题称为1号问题。<br>
那如何解决1号问题呢？同理，我们还需要解决2号问题就是比1号问题还要小一级的问题，<strong>和(arr[2]~arr[n])</strong> ,解决了2号问题，加个arr[1]，就可以解决我们的1号问题，那么也就解决了我们的原问题。你可以看到，我们要解决的问题都是一些同类型的问题。那么相当于2号问题还会有3号问题，4号问题等等等等。如果数组中有n个元素，最后元素的下标是(n-1),我们的第n-1号问题便是<strong>和([])</strong><br>
这就是最小的问题，这个最小问题是我们可以解决的，一个空数组的和当然是0了<br>
当计算到第n-1号问题时，函数中依然会调用sum(arr,n)而程序中没有索引为n的元素，意味着已经计算到了最小的问题，所以添加判断，当此时传入的n等于数组长度时，返回最小单元的值。解决了最小单元所有的问题便迎刃而解。这就时原理上我们为什么需要去解决这一问题，返回最小问题单元的解，这便是第一步。</li>
<li>第一步做好之后，我们只是返回了最小问题单元的值，要完成递归过程，我们还得让程序可以走到最小的问题单元，这便是递归。此时要站在原问题的角度，把1号问题的结果当作已知去解决我们的大问题。<code>return arr[0] + sum(arr, l+1);</code><br>
便是这个意思。</li>
</ol>
<h2 id="扩展练习">扩展练习</h2>
<p><a href="http://stevenhy.com/post/9KuaIONib/">之前有练习过一道LeetCode链表题，我提到了三种解法</a>，题目是给一个链表的头节点，和一个val值，要求删除链表中值为val的节点，最后返回删除好的链表的头节点。<br>
这里再贴一下当时的递归解法：</p>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null) return null;
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
</code></pre>
<p>贴一下这个递归解法的图解操作：<br>
<img src="http://stevenhy.com/post-images/1565760505529.png" alt=""></p>
<p><img src="http://stevenhy.com/post-images/1565760687560.png" alt=""><br>
看完图解，对整个过程应该是很清楚了，如果还不了解，可以再程序中添加输出的方式，帮助理解整个过程。</p>
<pre><code class="language-java">public class Solution {

    public ListNode removeElements(ListNode head, int val, int depth) {

        String depthString = generateDepthString(depth);

        System.out.print(depthString);
        System.out.println(&quot;Call: remove &quot; + val + &quot; in &quot; + head);

        if(head == null){
            System.out.print(depthString);
            System.out.println(&quot;Return: &quot; + head);
            return head;
        }

        ListNode res = removeElements(head.next, val, depth + 1);
        System.out.print(depthString);
        System.out.println(&quot;After remove &quot; + val + &quot;: &quot; + res);

        ListNode ret;
        if(head.val == val)
            ret = res;
        else{
            head.next = res;
            ret = head;
        }
        System.out.print(depthString);
        System.out.println(&quot;Return: &quot; + ret);

        return ret;
    }

    private String generateDepthString(int depth){
        StringBuilder res = new StringBuilder();
        res.append(&quot;depth &quot;);
        res.append(depth);
        res.append(&quot; &quot;);
        for(int i = 0 ; i &lt; depth ; i ++)
            res.append(&quot;--&quot;);
        return res.toString();
    }

    public static void main(String[] args) {

        int[] nums = {1, 2, 6, 3, 4, 5, 6};
        ListNode head = new ListNode(nums);
        System.out.println(head);

        ListNode res = (new Solution()).removeElements(head, 6, 0);
        System.out.println(res);
    }

}
</code></pre>
<p><strong>运行结果如下：</strong></p>
<pre><code class="language-java">1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL
depth 0 Call: remove 6 in 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL
depth 1 --Call: remove 6 in 2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL
depth 2 ----Call: remove 6 in 6-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL
depth 3 ------Call: remove 6 in 3-&gt;4-&gt;5-&gt;6-&gt;NULL
depth 4 --------Call: remove 6 in 4-&gt;5-&gt;6-&gt;NULL
depth 5 ----------Call: remove 6 in 5-&gt;6-&gt;NULL
depth 6 ------------Call: remove 6 in 6-&gt;NULL
depth 7 --------------Call: remove 6 in null
depth 7 --------------Return: null
depth 6 ------------After remove 6: null
depth 6 ------------Return: null
depth 5 ----------After remove 6: null
depth 5 ----------Return: 5-&gt;NULL
depth 4 --------After remove 6: 5-&gt;NULL
depth 4 --------Return: 4-&gt;5-&gt;NULL
depth 3 ------After remove 6: 4-&gt;5-&gt;NULL
depth 3 ------Return: 3-&gt;4-&gt;5-&gt;NULL
depth 2 ----After remove 6: 3-&gt;4-&gt;5-&gt;NULL
depth 2 ----Return: 3-&gt;4-&gt;5-&gt;NULL
depth 1 --After remove 6: 3-&gt;4-&gt;5-&gt;NULL
depth 1 --Return: 2-&gt;3-&gt;4-&gt;5-&gt;NULL
depth 0 After remove 6: 2-&gt;3-&gt;4-&gt;5-&gt;NULL
depth 0 Return: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
</code></pre>
<p>这样就很清晰了，对递归的深度的理解也会比较到位💦</p>
<hr>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/9KuaIONib1/">http://stevenhy.com/post/9KuaIONib1/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode203 - 链表移除问题的三种解决方案]]></title>
        <id>http://stevenhy.com/post/9KuaIONib</id>
        <link href="http://stevenhy.com/post/9KuaIONib">
        </link>
        <updated>2019-08-14T01:18:53.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode中的203题, 链表移除的三种解决方案, 借此巩固链表知识</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode中的203题, 链表移除的三种解决方案, 借此巩固链表知识</p>
<!-- more -->
<h2 id="解决方案1">解决方案1</h2>
<p>1号方案理解起来相当容易, 与之前介绍的删除节点的方法原理一致, 需要找到每个节点的前驱节点, 由于头节点没有前驱节点所以需要另行处理, 具体看解法中的注释内容.</p>
<pre><code class="language-java">/*
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //首先处理头结点需删除的条件,若头结点被删除, 那么下一个就变成了头节点
				//所以这里加了while循环用来判断每一个头结点是否需要删除
		while (head != null &amp;&amp; head.val == val) {
            ListNode delNode = head;
            head = head.next;
            delNode.next = null; 
      }
				//执行到这里头结点的删除已经完毕, 此时链表中有两种情况
				//1.链表有剩余元素
				//2.链表中全是需要删除的元素, 到此已删除完毕
				//所以需要判断, 分情况对待
        if(head == null)
            return null;
        //进入第一种情况的处理
				ListNode prev = head;
        while (prev.next != null) {
            if (prev.next.val == val) {
                ListNode delNode = prev.next;
                prev.next = delNode.next;
                delNode.next = null;
            }
            else
                prev = prev.next;
        }
        return head;
    }
}
</code></pre>
<p>提交结果:</p>
<pre><code class="language-java">√ Accepted
  √ 65/65 cases passed (2 ms)
  √ Your runtime beats 92.77 % of java submissions
  √ Your memory usage beats 66.77 % of java submissions (43.5 MB)
</code></pre>
<p>对于算法而言, 我们本身其实不需要太多顾及loietory object的问题,因为所有的内存在提交判断后都会被销毁的, 因此我们换掉几句</p>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        while(head != null &amp;&amp; head.val == val){
            head = head.next;
    }
        if(head == null)
            return head;
        
        ListNode prev = head;
        while(prev.next != null){
            if(prev.next.val == val)
                prev.next = prev.next.next;
            else
                prev = prev.next;
        }
        return head;
    }
}
</code></pre>
<p>提交后结果如下:</p>
<pre><code class="language-java">√ Accepted
  √ 65/65 cases passed (2 ms)
  √ Your runtime beats 92.77 % of java submissions
  √ Your memory usage beats 67.41 % of java submissions (43.3 MB)
</code></pre>
<h2 id="解决方案2">解决方案2</h2>
<p>就删除操作来看, 如果每个节点都有它的头结点 ,那么就非常好办了, 所以我们同样可以为头节点添加一个虚拟头结点来作为它的前驱, 这样就不需要为头结点设置独立的操作语句了.</p>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        
        ListNode dummyHead = new ListNode(-1); //这里的值没有任何意义，因为不会被访问到
        dummyHead.next = head;

        ListNode prev = dummyHead;
        while(prev.next != null){
            if(prev.next.val == val)
                prev.next = prev.next.next;
            else
                prev = prev.next;
        }
        
        return dummyHead.next;
    }
}
</code></pre>
<p>提交结果如下:</p>
<pre><code class="language-java">√ Accepted
  √ 65/65 cases passed (2 ms)
  √ Your runtime beats 92.77 % of java submissions
  √ Your memory usage beats 60.74 % of java submissions (43.9 MB)
</code></pre>
<p>👌看来这样也是可以的, 尤其和之前的解决方案相比, 代码量少了不少, 看起来更轻便.</p>
<h2 id="解决方案3">解决方案3</h2>
<p>之所以有第三种解决方案是因为链表有着天然的递归特性, 所以我们可以借此特性利用递归的方式来解决本题.具体思路如下图<br>
<img src="http://stevenhy.com/post-images/1565753207243.png" alt=""></p>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null)
            return null;
        
        ListNode res = removeElements(head.next, val);
        if(head.val == val)
            return res;
        else{
            head.next = res;
            return head;
        }
    }
}
</code></pre>
<p>提交结果如下</p>
<pre><code class="language-java">√ Accepted
  √ 65/65 cases passed (2 ms)
  √ Your runtime beats 92.77 % of java submissions
  √ Your memory usage beats 58.13 % of java submissions (44 MB)
</code></pre>
<p>这其中的语句还可以优化</p>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null)
            return null;
        
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
    }
}
</code></pre>
<p>提交结果如下:</p>
<pre><code class="language-java">√ Accepted
  √ 65/65 cases passed (2 ms)
  √ Your runtime beats 92.77 % of java submissions
  √ Your memory usage beats 67.23 % of java submissions (43.4 MB)
</code></pre>
<h2 id="总结">总结</h2>
<p>以上就是针对于LeetCode 203 问题的三种解决方案, 对于第三种解决方案, 我会在另一篇博文<a href="http://stevenhy.com/post/9KuaIONib1/">深入理解递归的运行机制</a><br>
详细分析, 感谢阅读!</p>
<hr>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/9KuaIONib/">http://stevenhy.com/post/9KuaIONib/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构回顾 - 链表实现及应用]]></title>
        <id>http://stevenhy.com/post/FiTjgJh8i</id>
        <link href="http://stevenhy.com/post/FiTjgJh8i">
        </link>
        <updated>2019-08-13T10:03:28.000Z</updated>
        <summary type="html"><![CDATA[<p>之前我们自己编写了动态数组, 并以此实现了栈和队列,但是我们所谓的动态数组底层依然是依托于静态数组, 称其为动态是因为可以适时对容量做出控制.  今天来回顾一个非常重要的数据结构-链表. 相较于动态数组, 链表可谓是真正意义上的动态结构.</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前我们自己编写了动态数组, 并以此实现了栈和队列,但是我们所谓的动态数组底层依然是依托于静态数组, 称其为动态是因为可以适时对容量做出控制.  今天来回顾一个非常重要的数据结构-链表. 相较于动态数组, 链表可谓是真正意义上的动态结构.</p>
<!-- more -->
<h2 id="1linkedlist类的编写">1.LinkedList类的编写</h2>
<p>相较于静态数组来说, 链表最大的优势在于实现了真正的动态, 但是丧失了根据索引随机访问的能力. 但是我们学习链表的目的绝不仅限于此, 事实上链表是一种最简单的动态数据结构, 掌握好链表会为之后的更难的数据结构打好基础, 同时也有利于更深入的理解引用及递归的知识.</p>
<p>废话不多说, 开始写代码</p>
<pre><code class="language-java">public class LinkedList&lt;E&gt; {
	private class Node{
		public E e;
		public Node next;
		
		public Node(E e, Node next) {
			this.e = e;
			this.next = next;
		}
		
		public Node(E e) {
			this(e, null);
		}
		
		public Node() {
			this(null, null);
		}
		
		@Override
		public String toString() {
			return e.toString();
		}
	}

	private Node head;
	private int size;

	//构造方法
	public LinkedList() {
		head = null;
		size = 0;
	}

	//获取链表中元素个数
	public int getSize() {
		return size;
	}

	//判断链表是否为空
	public boolean isEmpty() {
		return size==0;
	}

	//在链表头部添加元素
	public void addFirst(E e) {
		/*Node node = new Node(e);
		node.next = head;
		head =node;*/
		head = new Node(e, head); //一行代码更优雅
		size++;
	}
	
	//在链表中间添加元素,在'索引'为index的时候添加元素e
	public void add(int index,E e) {
		if(index &lt; 0 || index &gt;size)
			throw new IllegalArgumentException(&quot;Add failed. Illegal index.&quot;);
		
		if(index == 0)
			addFirst(e);
		else{	
			Node prev = head;
			for(int i=0; i&lt;index-1; i++) 
				prev = prev.next;
			/*Node node = new Node(e);
			node.next = prev.next;
			prev.next = node;*/
			prev.next = new Node(e, prev.next); //同样比较轻便
			size++;
		
		} 
	}		
	
	 //向链表尾部添加元素
	public void addLast(E e) {
		add(size, e);
	}

}
</code></pre>
<p>写到这里, 我便感觉有点不对, 虽然说实际中对链表的操作不会从中间元素开刀, 但是对于我们梳理学习链表知识, 缺需要练习对中间元素的操作, 以便深入理解链表. 从上面的add操作 可以看出, 这样写的话, 需要判断的内容甚多, 尤其在表头前添加元素时, 由于没有前驱, 需要另行编写代码, 比较繁琐. 于是为了统一操作, 我们设立一个虚拟头结点放在表头元素的前面, 该虚拟头结点不存放任何数据, 只起辅助作用.这样会方便很多, 于是 重来一遍!😂<br>
**先声明：一下中的index指的时用户眼中的index,用户 并不知道有虚拟头节点，且数据位置从0开始计数！</p>
<pre><code class="language-java">public class LinkedList改进&lt;E&gt; {
	private class Node{
		public E e;
		public Node next;
		
		public Node(E e, Node next) {
			this.e = e;
			this.next = next;
		}
		
		public Node(E e) {
			this(e, null);
		}
		
		public Node() {
			this(null, null);
		}
		
		@Override
		public String toString() {
			return e.toString();
		}
	}

	private Node dummyHead;
	private int size;
	
	//构造方法
	public LinkedList改进() {
		dummyHead = new Node(null, null); //采用虚拟头结点
		size = 0;
	}
	
	//获取链表中元素个数 O(1)
	public int getSize() {
			return size;
		}

	//判断链表是否为空 O(1)
	public boolean isEmpty() {
		return size==0;
	}

	//向链表中index位置(从0开始),添加元素e O(1/2n)=O(n)
	public void add(int index, E e) {
		//1.判断index是否合法, 不合法抛出异常
		if(index &lt; 0 || index &gt; size)
			throw new IllegalArgumentException(&quot;Add Failed. Illegal index.&quot;);
		//2.添加元素,有了虚拟头结点不用担心0位置的元素没有前驱
		Node pre = dummyHead;
		for(int i=0; i&lt;index ;i++) 
			pre = pre.next;
		//3.此时pre中存放的便是待放入元素e的前驱节点
		//Node node = new Node(e);
		//node.next = pre.next;
		//pre.next = node;
		//上面的步骤3可简化为一句,显得优雅轻便
		 pre.next = new Node(e, pre.next);
		//4.此时元素已经进入链表, 我们需要维护一下size变量
		size++;
		//O(1/2n)=O(n)
	}
	
	//借助add操作完成向表头添加元素的位置  O(1)
	public void addFirst(E e) {
		add(0,e);  //O(1)
	}
	
	//向链表尾部添加元素e  O(n)
	public void addLast(E e) {
		add(size, e);   //O(n)
	}
	
	//获取index位置的元素, 这里的index是用户层面的  O(n)
	public E get(int index) {
		if(index &lt; 0 || index &gt; size)
			throw new IllegalArgumentException(&quot;get Failed. Illegal index.&quot;);
		
		Node cur = dummyHead.next;
		for(int i=0; i&lt;index; i++) 
			cur = cur.next;
		return cur.e;
	}
	
	//获取第一个元素  O(1)
	public E getFist() {
		return get(0);
	}
	
	//获取最后一个元素  O(n)
	public E getLast() {
		return get(size-1);
	}
	
	//修改链表中的第index个位置的元素为e  O(n)
	//在链表中不是一个常用操作, 练习用
	public void set(int index, E e) {
		//1.惯例先判断index是否合法
		if(index &lt; 0 || index &gt; size)
			throw new IllegalArgumentException(&quot;Set Failed. Illegal index.&quot;);
		//2.确定index位置元素节点
		Node cur = dummyHead.next;
		for(int i=0; i&lt;index ;i++)
			cur = cur.next;
		cur.e = e;
	}
	
	//修改表头元素
	public void setFirst(E e) {
		set(0, e);
	}
	
	//查找链表中是否存在元素e  O(n)
	public boolean contains(E e) {
		Node cur = dummyHead.next;
		while(cur != null) {
			if(cur.equals(e))
				return true;
			cur = cur.next;
		}
		return false;
	}
	
	@Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		
		/*Node cur = dummyHead.next;
		while(cur != null) {
			res.append(cur + &quot;-&gt;&quot;);
			cur = cur.next;
		}*/
		for(Node cur = dummyHead.next ; cur != null ; cur = cur.next)
			res.append(cur + &quot;-&gt;&quot;);
		res.append(&quot;NULL&quot;);  //与上面的遍历方式作用相同
		
		return res.toString();
	}
	
	//从链表中删除index位置的元素, 并返回删除元素  O(n)
	//在链表中并不是一个常用的操作, 练习用
	public E remove(int index) {
		
		//1.老规矩, 先判断index是否合法
		if(index &lt; 0 || index &gt; size)
			throw new IllegalArgumentException(&quot;Remove Failed. Illegal index.&quot;);
		//2.找到要删除节点的前驱节点
		Node prev = dummyHead;
		for(int i=0; i&lt;index; i++)
			prev = prev.next;
		//3.找到待删除的节点,并确定返回值
		Node dele = dummyHead.next;
		for(int i=0; i&lt;index; i++)
			dele = dele.next;
		E ret = dele.e;
		//4.执行删除操作
		prev.next = dele.next;
		dele.next = null;
		//5.维护size变量
		size--;
		return ret;
		//O(1/2n)=O(n)
	}
	
	//删除第一个元素  O(1)
	public E removeFirst() {
		return remove(0);  //O(1)
	}
	
	//删除最后一个元素  O(n)
	public E removeLast() {
		return remove(size-1);   //O(n)
	}
	
	
}
</code></pre>
<p>验证一下吧</p>
<pre><code class="language-java">	public static void main(String[] args) {
		// TODO Auto-generated method stub
		LinkedList改进&lt;Integer&gt; linkedlist= new LinkedList改进&lt;&gt;();
		
		for(int i=0; i&lt;5;i++) {
			linkedlist.addFirst(i);
			System.out.println(linkedlist);
		}
		
		linkedlist.add(2, 666);
		System.out.println(&quot;After Add:&quot;);
		System.out.println(linkedlist);
		
		linkedlist.remove(2);
		System.out.println(&quot;After remove:&quot;);
		System.out.println(linkedlist);
		linkedlist.removeFirst();
		System.out.println(&quot;After removeFirst:&quot;);
		System.out.println(linkedlist);
		linkedlist.removeLast();
		System.out.println(&quot;After removeLast:&quot;);
		System.out.println(linkedlist);
	}
</code></pre>
<p>效果如下：</p>
<pre><code class="language-java">0-&gt;NULL
1-&gt;0-&gt;NULL
2-&gt;1-&gt;0-&gt;NULL
3-&gt;2-&gt;1-&gt;0-&gt;NULL
4-&gt;3-&gt;2-&gt;1-&gt;0-&gt;NULL
After Add:
4-&gt;3-&gt;666-&gt;2-&gt;1-&gt;0-&gt;NULL
After remove:
4-&gt;3-&gt;2-&gt;1-&gt;0-&gt;NULL
After removeFirst:
3-&gt;2-&gt;1-&gt;0-&gt;NULL
After removeLast:
3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<h2 id="2分析">2.分析</h2>
<p>至此，我们已经大致实现了链表，在编写过程中有这么几点需要注意：</p>
<ul>
<li>由于虚拟头节点的引入，在遍历链表的时候要注意循环条件，必要时需画图验证。</li>
<li>找index位置节点的前驱时，从dummyHead出发遍历index次，即可到前驱</li>
<li>找index位置的节点时，比如contains操作，从dummHead.next开始遍历index次到达。</li>
</ul>
<p>分析我们实现的链表各项操作的复杂度：</p>
<table>
<thead>
<tr>
<th>method</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>O(n)</td>
</tr>
<tr>
<td>addFirst</td>
<td>O(1)</td>
</tr>
<tr>
<td>addLast</td>
<td>O(n)</td>
</tr>
<tr>
<td>remove</td>
<td>O(n)</td>
</tr>
<tr>
<td>removeFirst</td>
<td>O(1)</td>
</tr>
<tr>
<td>removeLast</td>
<td>O(n)</td>
</tr>
<tr>
<td>set</td>
<td>O(n)</td>
</tr>
<tr>
<td>setFirst</td>
<td>O(1)</td>
</tr>
<tr>
<td>contains</td>
<td>O(n)</td>
</tr>
<tr>
<td>get</td>
<td>O(n)</td>
</tr>
<tr>
<td>getFirst</td>
<td>O(1)</td>
</tr>
<tr>
<td>getLast</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<h2 id="3拓展1">3.拓展1</h2>
<p>这里有个有意思的点 ，对于链表来说, 只有头结点的增删查操作是O(1), 非常快,想到了什么😂<br>
这恰恰是我们的栈所需要的结构啊！<br>
不用链表实现一下栈对不起我这一顿分析啊哈哈🙋‍♂️<br>
开搞！<br>
继续实现Stack接口，这时，你就要禁不住赞叹，多态大法好哇！😎</p>
<pre><code class="language-java">public class LinkedListStack&lt;E&gt; implements Stack&lt;E&gt; {
	
	private LinkedList改进&lt;E&gt; list;
	
	public LinkedListStack() {
		list = new LinkedList改进(); 
	}

	@Override
	public int getSize() {
		// TODO Auto-generated method stub
		return list.getSize();
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return list.isEmpty();
	}

	@Override
	public void push(E e) {
		// TODO Auto-generated method stub
		list.addFirst(e);
	}

	@Override
	public E pop() {
		// TODO Auto-generated method stub
		return list.removeFirst();
	}

	@Override
	public E peek() {
		// TODO Auto-generated method stub
		return list.getFist();
	}
	
	@Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		res.append(&quot;LinkedListStack: Top &quot;);
		res.append(list);
		return res.toString();
	}	
}
</code></pre>
<p>加一个main函数验证一下：</p>
<pre><code class="language-java">	public static void main(String[] args) {
		LinkedListStack&lt;Integer&gt; stack = new LinkedListStack&lt;&gt;();
		for(int i=0;i&lt;5;i++) {
			stack.push(i);
			System.out.println(stack);
		}
		stack.pop();
		System.out.println(stack);
	}
</code></pre>
<p>上效果</p>
<pre><code class="language-java">LinkedListStack: Top 0-&gt;NULL
LinkedListStack: Top 1-&gt;0-&gt;NULL
LinkedListStack: Top 2-&gt;1-&gt;0-&gt;NULL
LinkedListStack: Top 3-&gt;2-&gt;1-&gt;0-&gt;NULL
LinkedListStack: Top 4-&gt;3-&gt;2-&gt;1-&gt;0-&gt;NULL
LinkedListStack: Top 3-&gt;2-&gt;1-&gt;0-&gt;NULL
</code></pre>
<p>到这里用链表实现了栈,主要是对表头元素的增删查复杂度为O(1)的特点很适合栈。<br>
现在我们有了两种栈的实现方式，究竟哪一种性能好呢？来比比看啊</p>
<pre><code class="language-java">import java.util.Random;


public class Compare {

    // 测试使用stack运行opCount个push和pop操作所需要的时间，单位：秒
    private static double testStack(Stack&lt;Integer&gt; stack, int opCount){

        long startTime = System.nanoTime();

        Random random = new Random();
        for(int i = 0 ; i &lt; opCount ; i ++)
            stack.push(random.nextInt(Integer.MAX_VALUE));
        for(int i = 0 ; i &lt; opCount ; i ++)
            stack.pop();

        long endTime = System.nanoTime();

        return (endTime - startTime) / 1000000000.0;
    }

    public static void main(String[] args) {

        int opCount = 100000;

        ArrayStack&lt;Integer&gt; arrayStack = new ArrayStack&lt;&gt;();
        double time1 = testStack(arrayStack, opCount);
        System.out.println(&quot;ArrayStack, time: &quot; + time1 + &quot; s&quot;);

        LinkedListStack&lt;Integer&gt; linkedListStack = new LinkedListStack&lt;&gt;();
        double time2 = testStack(linkedListStack, opCount);
        System.out.println(&quot;LinkedListStack, time: &quot; + time2 + &quot; s&quot;);

        // 其实这个时间比较很复杂，因为LinkedListStack中包含更多的new操作
    }
}
</code></pre>
<p>具体比较下来也很客观, 在元素数量不是很大的时候链表栈性能要优于之前以动态数组为底层的栈, 这是因为动态数组中会时不时的进行resize操作, 当然如果元素数量巨大的时候（一千万）, 链表栈也会比动态数组栈要慢 一点, 究其原因 可能是由于链表内部有大量节点导致存在大量的new操作,使其变慢. 但是总体来讲这两种栈的时间复杂度是相同的, 虽然由于外部原因可能会存在一些性能差异, 但这些差异始终较小, 差不了多少.👌</p>
<h2 id="4拓展2">4.拓展2</h2>
<p>栈也搞完了， 同样的我们也可以拿链表来实现队列，为了实现以链表为底层的队列, 我们需要考虑几个问题, 对于链表来说, 只对表头元素进行增删查才可以实现<br>
O(1)的复杂度, 但是对于队列来说, dequeue操作需要出队操作, 不能只操作一端, 需涉及到表尾元素 这样复杂度就不是O(1)了, 如何解决? 回想在依托动态数组实现队列的时候也遇到了相应的问题, 我们的解决方案是添加了tail这一成员变量,专门记录队尾元素的位置, 同理我们也可以在链表中添加一个 tail节点用于记录表尾节点,这样对表尾的插入元素就会容易点. 还有一个问题, 我们要选用链表的哪一端进行入队操作呢? 就上面的复杂度分析来看, 对表头元素的增删都是O(1), 而对于表尾元素<br>
增是O(1), 删的话就麻烦一点, 因为我们还需要表尾元素的前驱节点. 分析下来, 结果就很显然了用表头做队首, 用表尾做队尾, 新增tail节点管理表尾位置, 复杂度为O(1), 而且因为队列不涉及对中间元素的操作,就不需要再用虚拟头结点了。</p>
<p>理清思路之后， 开始coding！💨<br>
同样，我们直接去实现Queue接口。</p>
<pre><code class="language-java">public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; {
   
   private class Node{
   	public E e;
   	public Node next;
   	
   	public Node(E e, Node next) {
   		this.e = e;
   		this.next = next;
   	}
   	
   	public Node(E e) {
   		this(e, null);
   	}
   	
   	public Node() {
   		this(null, null);
   	}
   	
   	@Override
   	public String toString() {
   		return e.toString();
   	}
   }

   private Node head;
   private Node tail;
   private int size;
   
   public LinkedListQueue() {
   	head = null;
   	tail = null;
   	size = 0;
   }

   @Override
   public int getSize() {
   	// TODO Auto-generated method stub
   	return size;
   }

   @Override
   public boolean isEmpty() {
   	// TODO Auto-generated method stub
   	return size==0;
   }

   @Override
   public void enqueue(E e) {
   	// TODO Auto-generated method stub
   	//1.判断此时队列是否为空
   	if(tail == null) {
   		tail = new Node(e);
   		head = tail;
   	}
   	else {
   		tail.next = new Node(e);
   		tail = tail.next;
   	}
   	size++;
   }

   @Override
   public E dequeue() {
   	// TODO Auto-generated method stub
   	if(isEmpty())
   		throw new IllegalArgumentException(&quot;Dequeue Failed. Queue is empty.&quot;);
   	Node ret = head;
   	head = head.next;
   	ret.next = null;
   	if(head == null)
   		tail = null;
   	size--;
   	return ret.e;
   }

   @Override
   public E getFront() {
   	// TODO Auto-generated method stub
   	return head.e;
   }
   
   public String toString() {
   	StringBuilder res = new StringBuilder();
   	res.append(&quot;LinkedListQueue: Front &quot;);
   	Node node = head;
   	while(node != null) {
   		res.append(node+&quot;-&gt;&quot;);
   		node = node.next;
   	}
   	res.append(&quot;NULL Tail&quot;);
   	return res.toString();
   }
}
</code></pre>
<p>ok，主体已经写完，加个main函数看看效果。</p>
<pre><code class="language-java">	public static void main(String[] args) {
   	LinkedListQueue&lt;Integer&gt; queue = new LinkedListQueue&lt;&gt;();
   	for(int i=0;i&lt;10;i++) {
   		queue.enqueue(i);
   		System.out.println(queue);
   		System.out.println();
   		if(i%3 == 2) {
   			queue.dequeue();
   			System.out.println(queue);
   			System.out.println();
   		}
   	}
   }
</code></pre>
<p>结果如下</p>
<pre><code class="language-java">LinkedListQueue: Front 0-&gt;NULL Tail

LinkedListQueue: Front 0-&gt;1-&gt;NULL Tail

LinkedListQueue: Front 0-&gt;1-&gt;2-&gt;NULL Tail

LinkedListQueue: Front 1-&gt;2-&gt;NULL Tail

LinkedListQueue: Front 1-&gt;2-&gt;3-&gt;NULL Tail

LinkedListQueue: Front 1-&gt;2-&gt;3-&gt;4-&gt;NULL Tail

LinkedListQueue: Front 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL Tail

LinkedListQueue: Front 2-&gt;3-&gt;4-&gt;5-&gt;NULL Tail

LinkedListQueue: Front 2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL Tail

LinkedListQueue: Front 2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;NULL Tail

LinkedListQueue: Front 2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL Tail

LinkedListQueue: Front 3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL Tail

LinkedListQueue: Front 3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;NULL Tail
</code></pre>
<p>现在我们有三种可以实现队列的方法了，分别是ArrayQueue, LoopQueue, LinkedListQueue. 现在来比较一下他们的性能吧！</p>
<pre><code class="language-java">public class Main {
		// 测试使用q运行opCount个enqueueu和dequeue操作所需要的时间，单位：秒
	    private static double testQueue(Queue&lt;Integer&gt; q, int opCount){

	        long startTime = System.nanoTime();

	        Random random = new Random();
	        for(int i = 0 ; i &lt; opCount ; i ++)
	            q.enqueue(random.nextInt(Integer.MAX_VALUE));
	        for(int i = 0 ; i &lt; opCount ; i ++)
	            q.dequeue();

	        long endTime = System.nanoTime();

	        return (endTime - startTime) / 1000000000.0;
	    }

	    public static void main(String[] args) {

	        int opCount = 100000;

	        ArrayQueue&lt;Integer&gt; arrayQueue = new ArrayQueue&lt;&gt;();
	        double time1 = testQueue(arrayQueue, opCount);
	        System.out.println(&quot;ArrayQueue, time: &quot; + time1 + &quot; s&quot;);

	        LoopQueue&lt;Integer&gt; loopQueue = new LoopQueue&lt;&gt;();
	        double time2 = testQueue(loopQueue, opCount);
	        System.out.println(&quot;LoopQueue, time: &quot; + time2 + &quot; s&quot;);
	        
	        LinkedListQueue&lt;Integer&gt; LinkedQueue = new LinkedListQueue&lt;&gt;();
	        double time3 = testQueue(LinkedQueue, opCount);
	        System.out.println(&quot;LinkedQueue, time: &quot; + time3 + &quot; s&quot;);
	}

}
</code></pre>
<p><strong>一起来看看结果叭</strong></p>
<pre><code class="language-java">ArrayQueue, time: 49.172133193 s
LoopQueue, time: 0.013723476 s
LinkedQueue, time: 0.008158352 s
</code></pre>
<br>
<p>这就是数据结构充满魅力的地方叭，一步步去探索最优解法，不断锻炼思维能力才是我们的终极目标鸭😄</p>
<br>
<p><strong>今天就到这里了嗷~</strong></p>
<hr>
<br>  
<p><strong>推荐阅读</strong><br>
<a href="http://stevenhy.com/post/sjjghg-zddcsx/">数据结构回顾-栈的底层实现</a><br>
<a href="http://stevenhy.com/post/RPOfy91HP/">数据结构回顾-队列的实现与优化</a><br>
<br></p>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/FiTjgJh8i/">http://stevenhy.com/post/FiTjgJh8i/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构回顾 - 队列的实现与优化]]></title>
        <id>http://stevenhy.com/post/RPOfy91HP</id>
        <link href="http://stevenhy.com/post/RPOfy91HP">
        </link>
        <updated>2019-08-12T12:40:31.000Z</updated>
        <summary type="html"><![CDATA[<p>之前我们实现了一个栈，栈是一种先进后出的数据结构(FILO), 那么在数据结构中还有一种先进先出的数据结构(FIFO)与之对应, 即队列, 今天我们一步步实现自己的队列并优化它!</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前我们实现了一个栈，栈是一种先进后出的数据结构(FILO), 那么在数据结构中还有一种先进先出的数据结构(FIFO)与之对应, 即队列, 今天我们一步步实现自己的队列并优化它!</p>
<!-- more -->
<h2 id="1需求分析">1.需求分析</h2>
<p>同样的我们在实现一个队列之前, 要搞清楚它要包含些什么功能, 同样的为了使队列支持多态性, 我们先定义一个接口<code>Queue</code>, 理清我们具体要实现的方法.</p>
<pre><code class="language-java">public interface Queue&lt;E&gt; {
	int getSize();       //获取队列中的元素个数
	boolean isEmpty();   //判断队列是否为空
	void enqueue(E e);    //入队
	E dequeue();             //出队
	E getFront();            //获取对首元素
}
</code></pre>
<p>明确目标之后我们开始编写具体的实现代码</p>
<h2 id="2编写">2.编写</h2>
<p>我们要编写的类为<code>ArrayQueue</code> , 并实现Queue接口.</p>
<pre><code class="language-java">publice class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; {
	//依然以我们之前创建的Array作为底层
	//这里的array是不需要用户看见的,用private关键字
	private Array&lt;E&gt; array; 

	//当用户知道具体容量时,提供有参构造方法
	public ArrayQueue(int capacity) {
		array = new Array&lt;&gt;(capacity);
	}

	//当用户不知道具体容量时,提供无参构造方法
	public ArrayQueue() {
		array = new Array&lt;&gt;(); 
	}
	
	@Override
	public int getSize() {
		// TODO Auto-generated method stub
		return array.getSize();
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return array.isEmpty();
	}

	@Override
	public void enqueue(E e) {
		// TODO Auto-generated method stub
		array.addlast(e);
	}

	@Override
	public E dequeue() {
		// TODO Auto-generated method stub
		return array.removeFirst(); //除该操作的复杂度是O(n), 其余都是O(1), 要解决用循环队列, 后面会优化
	}

	@Override
	public E getFront() {
		// TODO Auto-generated method stub
		return array.getFirst();
	}
	
	@Override
	public String toString(){	
		StringBuilder res = new StringBuilder();
		res.append(&quot;Queue: &quot;);
		res.append(&quot;Front [&quot;);
		for(int i=0;i&lt;array.getSize();i++) {
			res.append(array.get(i));
			if(i != array.getSize() - 1)
				res.append(&quot;, &quot;);
		}
		res.append(&quot;] tail&quot;);
		return res.toString();
	}
}
</code></pre>
<p>我们先来简单测试一下, 编写一个main方法如下:</p>
<pre><code class="language-java">public class Main {
		// TODO Auto-generated method stub
	public static void main(String[] args) {
		ArrayQueue&lt;Integer&gt; queue = new ArrayQueue&lt;&gt;();
		for(int i=0;i&lt;10;i++) {
			queue.enqueue(i);
			System.out.println(queue);
			//每隔三次出一次队
			if(i%3 == 2) {
				queue.dequeue();
				System.out.println(queue);
			}
		}
	}
}
</code></pre>
<p>结果如下</p>
<pre><code class="language-java">Queue: Front [0] tail
Queue: Front [0, 1] tail
Queue: Front [0, 1, 2] tail
Queue: Front [1, 2] tail
Queue: Front [1, 2, 3] tail
Queue: Front [1, 2, 3, 4] tail
Queue: Front [1, 2, 3, 4, 5] tail
Queue: Front [2, 3, 4, 5] tail
Queue: Front [2, 3, 4, 5, 6] tail
Queue: Front [2, 3, 4, 5, 6, 7] tail
Queue: Front [2, 3, 4, 5, 6, 7, 8] tail
Queue: Front [3, 4, 5, 6, 7, 8] tail
Queue: Front [3, 4, 5, 6, 7, 8, 9] tail
</code></pre>
<h2 id="3复杂度分析及优化方向">3.复杂度分析及优化方向</h2>
<p>我们来先来分析上面编写的<code>ArrayQueue</code>的各项操作的复杂度, 如下所示</p>
<table>
<thead>
<tr>
<th>method</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>getSize()</td>
<td>O(1)</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>O(1)</td>
</tr>
<tr>
<td>enqueue(E e)</td>
<td>O(1)  (均摊)</td>
</tr>
<tr>
<td>getFront()</td>
<td>O(1)</td>
</tr>
<tr>
<td>dequeue()</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>可以看出上面的操作, 除了<code>dequeue()</code>方法的复杂度是O(n)外, 其余方法复杂度均为O(1).<br>
这也就是我们的优化方向, 能不能把<code>dequeue()</code>操作的时间复杂度也降低到O(1)呢?<br>
答案是肯定的, 至于怎么解决, 我们现在一步步来分析<br>
首先, <code>dequeue()</code>的时间复杂度为O(n)的原因在于, 每次对队首元素进行出队操作时, 要对剩下的所有元素向前移动一位,  这对于我们的动态数组来说是必要的, 因为我们需要<code>size</code>来统计当前数组中的元素个数, size所存的永远是第一个空位置, 那么如果不移动, size的值就会不稳定, 无法准确得到数组元素个数, 即使可以得到,也不好维护.<br>
那么对于一个队列来讲, 是否一定要移动后面的元素呢? 大可不必! 从用户角度来想, 队列维护的是出队及入队序列, 我们只需要让元素保持一定的顺序即可, 不必强求对首必须在索引为0的位置上, 这样一来, 我们就得到了一种新的队列 <strong><code>循环队列</code></strong>, 元素不再移动之后, 复杂度即变为O(1).<br>
光说不练假把式, 我们来通过代码具体实现:<br>
还是实现之前定义的队列<code>Queue</code>接口, 此处便体会到, 多态设计模式的好处😁</p>
<pre><code class="language-java">public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; {
	
	private E[] data; //不在依赖原先的动态数组
	private int front, tail;
	private int size;
	
	//由于实际可存元素数量比数组长度少1, 故要容纳capacity个元素, 长度需为capacity+1
	public LoopQueue(int capacity) {
		data = (E[])new Object[capacity + 1];
		front = 0;
		tail = 0;
		size = 0;
	}
	
	public LoopQueue() {
		this(10);
	}
	
	public int getCapacity() {
		return data.length-1;
	}
	
	@Override
	public int getSize() {
		// TODO Auto-generated method stub
		return size;
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return front == tail;
	}

	//循环队列, 相应的逻辑要改变
	@Override
	public void enqueue(E e) {
		// TODO Auto-generated method stub
		int c = data.length;
		if((tail+1)%c == front)
			resize(getCapacity() * 2);
		data[tail] = e;
		tail = (tail + 1)% (data.length);
		size++;
		
	}

	//定义变容操作,道理同动态数组
	private void resize(int newCapacity) {
		// TODO Auto-generated method stub
		E[] newData = (E[])new Object[newCapacity+1];
		for(int i=0; i&lt;size ; i++)
			newData[i] = data[(i+front)%data.length];
		
		data = newData;
		front = 0;
		tail = size;
	}

	@Override
	public E dequeue() {
		// TODO Auto-generated method stub
		if(isEmpty())
			throw new IllegalArgumentException(&quot;Cannot dequeue from an empty queue!&quot;);
		E element = data[front];
		data[front] = null;
		front = (front+1)%data.length;
		size--;
		if(size == getCapacity()/4 &amp;&amp; getCapacity()/2!=0)
			resize(getCapacity()/2);
		return element;
	}

	@Override
	public E getFront() {
		// TODO Auto-generated method stub
		if(isEmpty())
			throw new IllegalArgumentException(&quot;Cannot getFront from an empty queue!&quot;);
		return data[front];
	}

	@Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		res.append(String.format(&quot;Queue: size = %d, capacity = %d\n&quot;,size, getCapacity()));
		res.append(&quot;front [&quot;);
		//两种遍历循环队列的方式, 另一种看resize中的遍历
		for(int i=front;i != tail; i = (i+1)%data.length) {
			res.append(data[i]);
			if((i +1)%data.length != tail)
				res.append(&quot;, &quot;);
		}
		res.append(&quot;] tail&quot;);
		return res.toString();
	}
}
</code></pre>
<p>同样,我们来验证一下,看看具体效果:</p>
<pre><code class="language-java">public class Main {
		// TODO Auto-generated method stub
	public static void main(String[] args) {
		LoopQueue&lt;Integer&gt; queue = new LoopQueue&lt;&gt;();
		for(int i=0;i&lt;10;i++) {
			queue.enqueue(i);
			System.out.println(queue);
			System.out.println();
			if(i%3 == 2) {
				queue.dequeue();
				System.out.println(queue);
				System.out.println();
			}
		}
	}
}
</code></pre>
<p><strong>效果如下</strong></p>
<pre><code class="language-java">Queue: size = 1, capacity = 10
front [0] tail

Queue: size = 2, capacity = 10
front [0, 1] tail

Queue: size = 3, capacity = 10
front [0, 1, 2] tail

Queue: size = 2, capacity = 5
front [1, 2] tail

Queue: size = 3, capacity = 5
front [1, 2, 3] tail

Queue: size = 4, capacity = 5
front [1, 2, 3, 4] tail

Queue: size = 5, capacity = 5
front [1, 2, 3, 4, 5] tail

Queue: size = 4, capacity = 5
front [2, 3, 4, 5] tail

Queue: size = 5, capacity = 5
front [2, 3, 4, 5, 6] tail

Queue: size = 6, capacity = 10
front [2, 3, 4, 5, 6, 7] tail

Queue: size = 7, capacity = 10
front [2, 3, 4, 5, 6, 7, 8] tail

Queue: size = 6, capacity = 10
front [3, 4, 5, 6, 7, 8] tail

Queue: size = 7, capacity = 10
front [3, 4, 5, 6, 7, 8, 9] tail
</code></pre>
<h2 id="优化总结">优化总结</h2>
<p>经优化, 将队列变为循环队列后, 我们再来看看时间复杂度:</p>
<table>
<thead>
<tr>
<th>method</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>getCapacity()</td>
<td>O(1)</td>
</tr>
<tr>
<td>getSize()</td>
<td>O(1)</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>O(1)</td>
</tr>
<tr>
<td>enqueue(E e)</td>
<td>O(1) (均摊)</td>
</tr>
<tr>
<td>dequeue()</td>
<td>O(1) (均摊)</td>
</tr>
</tbody>
</table>
<p>至此优化完成, 其实在上面实现循环队列的时候, 不用size成员变量也可实现所有功能, 大小则通过front和tail两个变量来计算, 需要考虑的方面还挺多, 姑且当做一个作业去做,锻炼能力, 等实现了在贴出来与各位交流!</p>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/RPOfy91HP/">http://stevenhy.com/post/RPOfy91HP/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构回顾 - 栈的底层实现]]></title>
        <id>http://stevenhy.com/post/sjjghg-zddcsx</id>
        <link href="http://stevenhy.com/post/sjjghg-zddcsx">
        </link>
        <updated>2019-08-12T09:48:39.000Z</updated>
        <summary type="html"><![CDATA[<p>🙎‍♂️💦之前在博客中, 从0实现了动态数组, 这个数组灵活性相当高, 在容量不够或者容量过大时都会进行<code>resize</code>操作, 且这个动态数组支持泛型, 任何对象都可以成为其元素。<br>
这次，我们依然自己来实现一个栈！</p>
]]></summary>
        <content type="html"><![CDATA[<p>🙎‍♂️💦之前在博客中, 从0实现了动态数组, 这个数组灵活性相当高, 在容量不够或者容量过大时都会进行<code>resize</code>操作, 且这个动态数组支持泛型, 任何对象都可以成为其元素。<br>
这次，我们依然自己来实现一个栈！</p>
<!-- more -->
<p>栈在学习过程中出现频率挺高， 举两个例子，第一个是撤销操作，就是我们在文本编辑器中常用到的撤销(Undo)操作，原理和栈是一个道理，还有一个是程序调用的系统栈，在对子过程进行调用的时候，会把主函数中子函数的入口地址存入栈中，待子过程调用完毕后，会从该系统栈中取出主函数中的位置，接着执行剩余的命令。</p>
<p>现在，我们来想一想该如何实现这个栈。🧐</p>
<h2 id="1需求分析">1.需求分析</h2>
<p>首先，我们把栈要实现的功能进行罗列：</p>
<pre><code class="language-java">	void push(E)    //进栈
	E pop()            //出栈
	E peek()          //查看栈顶元素
	int getSize()    //获取栈中元素个数
	boolean isEmpty()   //查看栈是否非空
</code></pre>
<p>以上就是我们在栈中要实现的功能，从用户角度来看，设计的栈支持这些操作就好，具体底层的实现，用户并不需要关心，底层实现有多种方式，为满足多态性要求，我们先设置一个<code>Stack</code>接口，定义出基本的操作， 然后我们可以利用以实现的动态数组，来构建自己的<code>ArrayStack</code>类，使其实现<code>Stack</code>接口，这样我们的栈也有了类似动态数组的自动调整容量的<code>resize()</code>方法。</p>
<h2 id="2具体实现">2.具体实现</h2>
<p><strong>Stack 接口定义如下</strong></p>
<pre><code class="language-java">public interface Stack&lt;E&gt; {
    int getSize();
    boolean isEmpty();
    void push(E e);
    E pop();
    E peek();
}
</code></pre>
<p><strong>ArrayStack 定义如下</strong></p>
<pre><code class="language-java">public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; {

	Array&lt;E&gt; array;
	
	//构造方法用于用户事先知道容量
	public ArrayStack(int capacity) {
		array = new Array&lt;&gt;(capacity);
	}
	//当用户不确定所需容量，提供无参构造函数
	public ArrayStack() {
		array = new Array&lt;&gt;();
	}
	
	
	@Override
	public int getSize() {
		// TODO Auto-generated method stub
		return array.getSize();
	}
	
	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return array.isEmpty();
	}

	public int getCapacity() {
		return array.getCapiticy();
	}
	
	@Override
	public E pop() {
		// TODO Auto-generated method stub
		return array.removeLast();
	}

	@Override
	public E peek() {
		// TODO Auto-generated method stub
		return array.getLast(); // 为方便，在Array类中添加了getLast()方法 
	}
	
	@Override
	public void push(E e) {
		// TODO Auto-generated method stub
		array.addlast(e); //时间复杂度复习中, 因为与动态数组一样要考虑到resize操作, 故用均摊法分析复杂度为O(1)
	}
	
	@Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		res.append(&quot;Stack: [&quot;);
		//res.append(array.toString());
		for(int i=0; i&lt;array.getSize(); i++) {
			res.append(array.get(i));
			if(i != array.getSize()-1)
				res.append(',');
		}
		res.append(&quot;] top&quot;);
		return res.toString();
	}
	
	
}
</code></pre>
<p>这样我们的栈就定义好了。</p>
<h2 id="3复杂度分析">3.复杂度分析</h2>
<p>接着我们需要分析它各项操作的时间复杂度来大致衡量性能<br>
<strong>ArrayStack</strong></p>
<table>
<thead>
<tr>
<th>method</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>push</td>
<td>O(1)  均摊</td>
</tr>
<tr>
<td>pop</td>
<td>O(1)  均摊</td>
</tr>
<tr>
<td>peek</td>
<td>O(1)</td>
</tr>
<tr>
<td>getSize</td>
<td>O(1)</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h2 id="4验证结果">4.验证结果</h2>
<p>编写main方法进行验证，如下：</p>
<pre><code class="language-java">public class Main {
		public static void main(String[] args) {
		ArrayStack&lt;Integer&gt; stack = new ArrayStack&lt;&gt;();
		for(int i=0;i&lt;5;i++) {
			stack.push(i);
			System.out.println(stack);
		}
		stack.pop();
		System.out.println(stack);
		}
}
</code></pre>
<p><strong>结果如下</strong><br>
Stack: [0] top<br>
Stack: [0,1] top<br>
Stack: [0,1,2] top<br>
Stack: [0,1,2,3] top<br>
Stack: [0,1,2,3,4] top<br>
Stack: [0,1,2,3] top<br>
<br></p>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/sjjghg-zddcsx/">http://stevenhy.com/post/sjjghg-zddcsx/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构回顾 - 从0实现动态数组]]></title>
        <id>http://stevenhy.com/post/shu-ju-jie-gou-hui-gu-cong-0-shi-xian-dong-tai-shu-zu</id>
        <link href="http://stevenhy.com/post/shu-ju-jie-gou-hui-gu-cong-0-shi-xian-dong-tai-shu-zu">
        </link>
        <updated>2019-08-11T13:34:53.000Z</updated>
        <summary type="html"><![CDATA[<p>学完数据结构已经一年有余，有好多细节都已经要忘记了，所以开了这么一个系列，对数据结构的基础知识进行回顾<br>
该系列用java语言来进行实现，同时也借此机会巩固一下Java的基础语法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>学完数据结构已经一年有余，有好多细节都已经要忘记了，所以开了这么一个系列，对数据结构的基础知识进行回顾<br>
该系列用java语言来进行实现，同时也借此机会巩固一下Java的基础语法。</p>
<!-- more -->
<h2 id="1-在自主实现一个动态数组之前不妨先来复习java中的数组基础知识">1. 在自主实现一个动态数组之前，不妨先来复习Java中的数组基础知识。</h2>
<p><strong>声明数组变量</strong></p>
<p>在声明数组变量时，Java提供了两种方式:</p>
<pre><code class="language-java">dataType[] arrayname  // java所倡导的方式
dataType arrayname[]  //与上面的方法效果相同,但不建议使用
</code></pre>
<p><strong>创建数组</strong></p>
<pre><code class="language-java">arrayRefVar = new dataType[arraySize];
//上面的语法做了两件事
//1.创建了一个dataType类型的arraySize大小的数组
//2.把这个数组的引用赋值给变量arrayRefVar

//同样的,数组的创建与声明可以用一条语句完成
dataType[] arrayRefVar = new dataType[arraySize];
//也可以用大括号对元素进行初始化
dataType[] arrayRefVar = new dataType[]{1,2,3,4,5};
</code></pre>
<p><strong>遍历数组</strong></p>
<pre><code class="language-java">//第一种遍历方式,for循环
for(int i=0; i&lt;arrayRefVar.length; i++)
      System.out.println(arrayRefVar[i]);
      
//第二种遍历方式
for(dataType element:arrayRefVar)
      System.out.println(arrayRefVar[i]);

</code></pre>
<h2 id="2-借助已有的静态数组自己实现动态数组">2. 借助已有的静态数组自己实现动态数组</h2>
<pre><code class="language-java">//建立一个Array类,作为动态数组类,Array类有两个私有变量,其中data是一个静态数组,
//size种永远存放着数组中第一个空位置, 其大小表示了数组中变量的个数.
//该动态数组支持泛型, 任何对象都可以成为数组成员变量
public class Array&lt;E&gt; {
	private E[] data;
	private int size;
	
	//构造函数，传入数组的容量capacity构造函数
	public Array(int capaticy) {
		data = (E[])new Object[capaticy];
		size = 0;
	}
	
	//无参的构造函数，默认数组的容量capacity=10
	public Array() {
		this(10);
	}
	
	//获取数组中元素的个数
	public int getSize() {
		return size;
	}
	
	//获取数组的容量
	public int getCapiticy() {
		return data.length;
	}
	
	//返回数组是否为空
	public boolean isEmpty() {
		return size == 0;
	}
	
	//向数组末尾添加元素
	public void addlast(E e) {
		
		add(size,e);
	}
	
	//向数组头部添加元素
	public void addFirst(E e) {
		add(0, e);
	}
	
	//再index位置添加一个新元素e
	public void add(int index, E e) {
		
		
		if(!(index&gt;=0 &amp;&amp; index&lt;=size))
			throw new IllegalArgumentException(&quot;Add failed. Require index &gt;=0 and index &lt;=size&quot;);
		
		if(size == data.length)
			//throw new IllegalArgumentException(&quot;AddLast faild. Array is full.&quot;);
			resize(2 * data.length);
		
			
			for(int i = size-1; i&gt;=index; i--)
			data[i+1] = data[i];
		
		data[index] = e;
		size++;
	}
	
	//获取index位置的元素
	E get(int index) {
		if(!(index&gt;=0 &amp;&amp; index&lt;size))
			throw new IllegalArgumentException(&quot;Get failed. Require index &gt;=0 and index &lt;size&quot;);
		
		return data[index];
	}
	
	//修改index位置的元素
	void set(int index, E e) {
		if(!(index&gt;=0 &amp;&amp; index&lt;size))
			throw new IllegalArgumentException(&quot;Set failed. Require index &gt;=0 and index &lt;size&quot;);
		
		data[index] = e;
	}
	
	//查找数组中是否存在元素e
	public boolean contains(E e) {
		for(int i=0; i&lt;size; i++) {
			if(data[i].equals(e))
				return true;
		}
		return false;
	}
	
	//查找元素e在数组中第一次出现的位置,如果e不存在则返回-1
	public int find(E e) {
		for(int i=0; i&lt;size; i++) {
			if(data[i].equals(e))
				return i;
		}
		return -1;
	}
	
	//从数组中删除第一个元素
	public E removeFirst() {
		return remove(0);
	}
	
	//从数组中删除最后一个元素
	public E removeLast() {
		return remove(size-1);
	}
	
	//删除index位置的元素,返回删除元素
	public E remove(int index) {
		if(!(index&gt;=0 &amp;&amp; index&lt;size))
			throw new IllegalArgumentException(&quot;Remove failed. Require index &gt;=0 and index &lt;=size&quot;);
		E ret = data[index];
		for(int i=index; i&lt;size-1 ;i++) {
			data[i] = data[i+1];
		}
		size -=1;
		data[size]=null; // loitering object != memory leak
		
		if(size == data.length / 2)
			resize(data.length / 2);
		
		return ret;
	}
	
	//删除数组中的第一个e元素
	public void removeElement(E e) {
		int index = find(e);
		if(index != -1)
			remove(index);
	}
	
	//删除数组中的所有e元素
	public void removeAllElement(E e) {
		System.out.printf(&quot;size is %d&quot;, size);
		for(int i=0;i&lt;size;i++) {
			if(data[i].equals(e)) {
				remove(i);
				i-=1;
			}
				
		}
	}
	
	@Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		res.append(String.format(&quot;Array: size = %d, capacity = %d\n&quot;,size, data.length));
		res.append('[');
		for(int i=0;i&lt;size;i++) {
			res.append(data[i]);
			if(i != size - 1)
				res.append(&quot;, &quot;);
		}
		res.append(']');
		return res.toString();
	}
	
	//动态变容，用均摊发分析，时间复杂度为O(1)!
	private void resize(int newcapacity) {
		E[] newdata = (E[])new Object[newcapacity];
		for(int i=0;i&lt;size;i++) 
			newdata[i] = data[i];
		data = newdata;
	}
	
	//同时看addLast和removeLast操作，在容量变换点重复操作两个方法，会一直有O(n),出现复杂度震荡
	//原因是由于removeLast操作过于(Eager)着急
	//解决：Lazy
	//当size为capacity的1/4时，缩容1/2；
}
</code></pre>
<p>至此动态数组已经基本搭建完成, 该动态数组的实现了自主扩容, 接下来我们对搭建好的动态数组进行性能分析..</p>
<h2 id="3时间复杂度分析">3.时间复杂度分析</h2>
<p>分析来看, 我们创建的动态数组完成了, 增 删 改 查 , 几类功能, 对于添加功能来看(add系列), 其中的<code>addLast</code>方法如果不考虑<code>resize</code>操作,时间复杂度为O(1), 但是<code>resize</code>操作的时间复杂度是O(n), 所以把<code>addLast</code>方法的时间复杂度记为O(n), 同理删除操作的时间复杂度也为O(n), 对于修改和查询操作,如果已知索引,时间复杂度均是O(1), 如果不知道索引, 那么时间复杂度就是O(n), 因此如果知道索引的话,数组结构的速度是非常快的.</p>
<h2 id="4优化">4.优化</h2>
<p>经过上面的分析, 我们对容量的<code>resize</code>操作好像性能很一般, 果真是这样吗?<br>
其实,我们在上面分析的时候漏掉了一个小细节, 就是<code>addLast</code>和<code>removeLast</code>两个方法不可能每次调用都会触发<code>resize</code>操作, 如果用O(n)来表示<code>resize</code>的时间复杂度, 显然是不合适的.</p>
<p>我们应该采取 <strong>均摊法</strong> 来分析, 如果容量是n, 那么<code>resize</code>会在第 n+1 次操作时触发, 即 n+1 次操作的执行次数是 n+n+1=2n+1 次, 2n+1/n+1 约等于2, 则时间复杂度是O(2)=O(1), 与n是没有关系的, 这样分析下来, <code>resize</code>操作的性能其实是较高的..</p>
<p>等等等等!</p>
<p>也许有细心的朋友已经发现了, 虽说照上面分析是O(1), 但是 我如果不停的触发<code>resize</code>操作的, 即我在一个容量边界不停执行<code>addLast</code> 和 <code>removeLast</code>操作, 那岂不是会一直触发<code>resize</code> 操作, 那么复杂度肯定不是O(1)了, 的确如此, 这样的情况应该考虑, 我们把这种情况称为发生了 <strong>复杂度震荡</strong> !</p>
<p>如何解决呢? 对于<code>addLast</code> 来说, 到了容量边界如果要继续增加元素, 那么扩容是必须的, 否则会抛出异常. 那么对于 <code>removeLast</code> 来说, 当实际需要容量是真实容量的1/2时, 把另一半的容量全部缩减是非必须的, 既然如此, 我们不妨把缩容量操作改为当实际元素个数是容量的1/4时, 在缩到1/2, Lazy 一点, 这样就不会产生 复杂度震荡的问题. 这样的将操作 <strong>Lazy</strong> 化的思路在算法中很常见, 灵活利用 <strong>Lazy</strong>策略, 有时会产生更好的性能!</p>
<pre><code class="language-java">	//删除index位置的元素,返回删除元素
	public E remove(int index) {
		if(!(index&gt;=0 &amp;&amp; index&lt;size))
			throw new IllegalArgumentException(&quot;Remove failed. Require index &gt;=0 and index &lt;=size&quot;);
		E ret = data[index];
		for(int i=index; i&lt;size-1 ;i++) {
			data[i] = data[i+1];
		}
		size -=1;
		data[size]=null; // loitering object != memory leak
            //改进后
		//防止最后缩容时出现size为0的情况，故加一个data.length/2!=0的条件
		if(size == data.length/4 &amp;&amp; data.length / 2 != 0)
			resize(data.length/2);
		
		return ret;
	}
</code></pre>
<br>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/shu-ju-jie-gou-hui-gu-cong-0-shi-xian-dong-tai-shu-zu/">http://stevenhy.com/post/shu-ju-jie-gou-hui-gu-cong-0-shi-xian-dong-tai-shu-zu/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java abstract类与接口]]></title>
        <id>http://stevenhy.com/post/2019-3-22-java-abstract-and-interface</id>
        <link href="http://stevenhy.com/post/2019-3-22-java-abstract-and-interface">
        </link>
        <updated>2019-03-21T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="关于abstract类与接口">关于abstract类与接口</h1>
]]></summary>
        <content type="html"><![CDATA[<h1 id="关于abstract类与接口">关于abstract类与接口</h1>
<!-- more -->
<h2 id="1如何理解abstract">1.如何理解abstract</h2>
<p>举个简单的例子，我们要编写一个可以计算柱状体体积的一个程序，我们会用到下面这个计算公式：</p>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mo>=</mo><mi>B</mi><mi>o</mi><mi>t</mi><mi>t</mi><mi>o</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>e</mi><mi>a</mi><mo>∗</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Volum = Bottomarea * height
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span></span></p>
<p>对于<code>heigth</code>来说，我们很容易确定它的数值，可是对于<code>Bottomarea</code>就不是那么容易了，<br>
我们需要根据不同的形状来求出它的值，比如矩形，圆形或者是一个三角形等等。<br>
我们不可能考虑到所有的情况（这样非常耗费精力与时间）。<br>
但是体积的计算公式时很明确的，那么是否可以把<code>Bottomarea</code>当成已知量，只关注功能的实现。<br>
具体柱体的底面积是什么，根据确定需求来调用实现呢？<br>
 这样，有了<code>abstract</code>的出现。</p>
<p>在Java中，我们可以定义一个abstract类来实现具体的功能，至于一些功能的细节，由其子类去具体调用该功能时给出。<br>
根据上例，我们来定义一个这样的类：</p>
<pre><code class="language-java">abstract class Geometry {
    public abstract double getArea(); 
}//将所有计算面积的方法抽象成一个方法，不再考虑具体细节


//定义一个柱类 Piallar
public class  Pillar {
    Gemetry bottom;//bottom是抽象类Geometry声明的变量
    double height;
    Pillar (Geometry bottom, double height) {
        this.bottom = bottom;
        this.height = height;
    }
    public double getVolum() {
        if(bottom==null) {
            System.out.println(&quot;没有底，无法计算体积&quot;);
            return -1;
        }
        return bottom.getArea()*height;
        //bottom可以调用子类重写的getarea()方法
    }
}
</code></pre>
<p><strong>以下给出<code>abstract</code>类在定义时需要注意的一些要点：</strong></p>
<ol>
<li><code>abstract</code>不能用new运算符创建对象，必须创建其子类，由其子类创建对象。</li>
<li><code>abstract</code>类中的<code>abstract</code>方法只允许声明而不允许实现，其子类必须实现其继承的<code>abstract</code>方法，即重写<code>abstract</code>方法。</li>
<li>一个<code>abstract</code>类只关心子类是否具有某种功能，不关心功能的具体实现。具体实现由子类负责。</li>
<li>抽象类中可以包含抽象方法，为所有子类定义一个统一的接口，具体实现由子类完成。</li>
<li>抽象类中不一定要包含<code>abstract</code>方法，但是，一旦某个类中包含了<code>abstract</code>方法，则这个类必须声明为<code>abstract</code>类。</li>
</ol>
<p>子类实现举例：</p>
<pre><code class="language-java">//当底面是圆形时
public class Circle extends Geometry {
    double r;
    Circle(double r) {
        this.r = r;
    }
    public double getArea() {
        return(3.14*r*r);
    }
}

public class APP {
    public static void main(String args[]) {
        Piallar piallar;
        Geometry bottom = new Circle(10);//指定其底面为圆形
        piallar = new Piallar(bottom 100);
        System.out.println(&quot;体积&quot;+piallar.getVolum());
    }
}

</code></pre>
<blockquote>
<p><strong>总结</strong><br>
通过面向抽象来设计Piallar类，使得Piallar类不再依赖具体不变的类，当我们增加一个Triangle的子类，我们不需要修改Piallar类的任何代码，就可以创建出具有三角形底的柱体。</p>
</blockquote>
<p>总体来说，面向抽象编程的目的是为了应对用户需求的变化。核心是让类中每种可能的变化<br>
对应的交给抽象类的一个子类去负责，避免所设计的类依赖于具体的实现。</p>
<hr>
<h2 id="接口与实现">接口与实现</h2>
<p>  由于Java不支持多继承性，即一个类只能有一个父类，当子类里要实现多个方法时，便显得捉襟见肘（只能继承一个抽象类），为了克服单继承的缺点，Java提供了接口。<br>
接口定义的是多个类的共同行为规范，这些行为是与外部交流的通道，因此，接口定义的是一组公用方法。<br>
  使用关键字<code>interface</code>来定义一个接口</p>
<ul>
<li>接口体中包含常量定义和方法定义两部分。接口体中只进行方法的声明，不许提供方法的实现，所以，方法的定义没有方法体，且用分号“；”结尾 。</li>
<li>接口中的方法被默认是public和abstract的，接口在声明方法时可以省略方法前面的public和abstract关键字，但是，类在实现接口方法时，一定要用public来修饰。</li>
<li>类实现的接口方法以及接口中的常量可以被类的对象调用。</li>
</ul>
<pre><code class="language-java">interface Printable {
    final int Max = 100;
    void add();
    float sum(float x, float y);
}
</code></pre>
<p>实现接口用关键字<code>implements</code>声明，如果要实现多个接口，用逗号隔开接口名</p>
<pre><code class="language-java">class A implements Printable,Addable {
    //A类实现了Printable，Addable接口。
    }
</code></pre>
<p>体会以下例子中接口的调用：</p>
<pre><code class="language-java">

import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        String a,b;
        Scanner reader = new Scanner(System.in);
        a = reader.next();
        b = reader.next();
        Paper p = new A4Paper();//接口回调
        A4Paper.name = a;
        Printer printer = new Printer();
        printer.Print(p);
        p = new A6Paper();//接口回调
        A6Paper.name = b;
        printer.Print(p);
    }

}

interface Paper {
    String GetName();
}

class A4Paper implements Paper {
    static String name;
    public String GetName() {
        return A4Paper.name;
    }
}

class A6Paper implements Paper {
    static String name;
    public String GetName() {
        return A6Paper.name;
    }
}

class Printer {
    public void Print(Paper p) {
        System.out.println(p.GetName());
    }
}

</code></pre>
<p><strong>要点</strong></p>
<ul>
<li>接口中所有成员，包括属性、方法、内部类都是public访问权限</li>
<li>不管是否使用public static final修饰符，接口里的属性总是用这三个修饰符来修饰，即：接口中只能有常量</li>
<li>接口中的方法都是抽象方法，系统自动为其添加abstract修饰符</li>
<li>接口中不允许定义static方法</li>
<li>接口不能用于创建实例，但接口可用于声明引用类型的变量，这个引用类型的变量必须引用到其实现类的对象。<br>
例如：Computable c=new Computable();       X<br>
   Computable c=new A();    √</li>
</ul>
 <br>  
<hr>
<br>  
<h2 id="abstract类与接口的比较">abstract类与接口的比较</h2>
<ul>
<li><code>abstract</code>类和接口都可以有<code>abstract</code>方法。</li>
<li>接口中只可以有常量，不能有变量；而<code>abstract</code>类中即可以有常量也可以有变量。</li>
<li><code>abstract类</code>中也可以有非abstract方法，接口不可以。</li>
<li>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么</li>
<li>抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。即：抽象类要被子类继承，接口要被类实现。</li>
<li>接口作为系统与外界交互的窗口，体现的是一种规范。类似于整个系统的“总纲”，制定了系统各模块应该遵循的标准，因此一个接口不应该经常改变。在一个程序中，接口是多个模块间的耦合标准；在多个应用程序之间使用接口，接口是多个应用程序间的通信标准。</li>
<li>抽象类体现的是一种“模板”式设计。抽象类作为多个子类的抽象父类，可被当做系统实现过程中的中间产品，实现了系统部分功能，需要进一步完善才能成为最终产品。<br>
<br></li>
</ul>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/2019-3-22-java-abstract-and-interface/">http://stevenhy.com/post/2019-3-22-java-abstract-and-interface/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python ccf题解 201803-1 跳一跳]]></title>
        <id>http://stevenhy.com/post/2019-02-22-ccf-csp-tiaoyitiao</id>
        <link href="http://stevenhy.com/post/2019-02-22-ccf-csp-tiaoyitiao">
        </link>
        <updated>2019-02-22T00:07:03.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="201803-1跳一跳">201803-1跳一跳</h2>
]]></summary>
        <content type="html"><![CDATA[<h2 id="201803-1跳一跳">201803-1跳一跳</h2>
<!-- more -->
<p>项目 | 相关说明<br>
试题编号 | 201703-1<br>
试题名称 | 跳一跳<br>
时间限制 | 1.0s<br>
内存限制 | 256m<br>
问题描述 |近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。<br>
　　简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。<br>
　　如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8...）。<br>
　　现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。</p>
<p>输入格式</p>
<p>输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。</p>
<p>输出格式</p>
<p>输出一个整数，为本局游戏的得分（在本题的规则下）。</p>
<p>样例输入</p>
<p>1 1 2 2 2 1 1 2 2 0</p>
<p>样例输出</p>
<p>22</p>
<p>数据规模和约定</p>
<h2 id="对于所有评测用例输入的数字不超过30个保证0正好出现一次且为最后一个数字">对于所有评测用例，输入的数字不超过30个，保证0正好出现一次且为最后一个数字。</h2>
<h1 id="代码片段">代码片段</h1>
<pre><code class="language-python"> #跳一跳
score = 0
last = 1
alist = list(map(int,input().split()))
for a in alist:
    if a == 0:  # 若a为0则跳出循环
        break
    elif a == 1:
        last = 1
        score += a
    else:  # 跳到中心
        if last == 1:
            last = 2
        else:
            last = last + 2
        score += last
print(score)
</code></pre>
<h2 id="last的设置是解决本题的核心作用类似于flag可以起到遇1重置遇2累加的作用">last的设置是解决本题的核心，作用类似于flag，可以起到遇1重置，遇2累加的作用</h2>
<p><a href="https://postimg.cc/qz02QzsN"><img src="https://i.postimg.cc/TY5QdbhJ/7178.png" alt="7178.png"></a></p>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/2019-02-22-ccf-csp-tiaoyitiao/">http://stevenhy.com/post/2019-02-22-ccf-csp-tiaoyitiao/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java子类与继承相关知识点]]></title>
        <id>http://stevenhy.com/post/2019-3-22-java-class-and-extends</id>
        <link href="http://stevenhy.com/post/2019-3-22-java-class-and-extends">
        </link>
        <updated>2019-02-21T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>Java子类与继承相关知识点</p>
]]></summary>
        <content type="html"><![CDATA[<p>Java子类与继承相关知识点</p>
<!-- more -->
<h2 id="1子类与父类">1.子类与父类</h2>
<p>子类是由继承产生的，由关键词<code>extends</code>实现，例如当A类继承B类时，A类就是子类<br>
B类是父类。子类可以继承父类中不是<code>Private</code>的属性和方法作为自己的方法。<br>
若子类与父类不在同一包内则只能继承<code>public</code>和<code>protected</code>修饰的变量和方法。</p>
<h2 id="2成员变量的隐藏及方法的重写">2.成员变量的隐藏及方法的重写</h2>
<p>当子类新定义的成员变量与父类存在同名时，从父类那里继承来的成员变量就会被隐藏，<br>
子类不可直接调用，但可以通过从父类继承的方法进行调用。<br>
同时子类也可以重写从父类继承来的方法，从而实现想要的功能，但是需要注意的是，<br>
方法的名字，参数个数，参数类型，必须和父类的完全相同，不一样的只能是方法体。</p>
<h2 id="3super关键字">3.super关键字</h2>
<p>上面谈到，子类可以隐藏父类的成员变量及方法，那么如何调用这些被隐藏的变量及方法呢<br>
用<code>super</code>！当这些变量或方法被隐藏后就归super所有，例如<code>super.x</code> , <code>super.play()</code> ,<br>
分别调用了被子类隐藏的变量x和方法play。<br>
特别注意，当我们构造一个子类对象时，程序总会先构造该子类的父类对象，记住！<br>
<strong>子类不会继承父类的构造方法</strong> 也就是说，如果子类的构造方法没有明显的指出<br>
要使用父类的哪一个构造方法，子类会默认调用父类不带参数的构造方法。因此，子类在<br>
其构造方法中需要<code>super();</code>来调用父类的构造方法。(<s>没写也默认带</s>)<br>
<em><strong>例如仔细领悟如下代码中<code>super</code>的用法</strong></em></p>
<pre><code class="language-java">class Vehicle {
    int a;//轮子数
    double b;//自身重量
    Vehicle(int a, double b) {
        this.a=a;
        this.b=b;
    }
    void show() {
        System.out.println(&quot;汽车:&quot;);
        System.out.println(&quot;轮子数:&quot;+a+&quot;个&quot;);
        System.out.printf(&quot;自身重量:%.1f吨\n&quot;,b);
    }
}
class Car extends Vehicle {
    int c;//载客属性
    Car(int a, double b, int c) {
        super(a, b);//重点看这里的super！！！
        this.a = a;
        this.b = b;
        this.c = c;
    }
    void show() {
        System.out.println(&quot;小轿车:&quot;);
        System.out.println(&quot;轮子数:&quot;+a+&quot;个&quot;);
        System.out.printf(&quot;自身重量:%.1f吨\n&quot;,b);
        System.out.println(&quot;额定乘客数:&quot;+c+&quot;人&quot;);
    }
}
</code></pre>
<h2 id="4final关键字">4.final关键字</h2>
<p><code>final</code>关键字可以修饰类，成员变量和方法中的局部变量。<br>
被<code>final</code>修饰的类不能被继承，修饰的方法不能被重写，修饰的变量成了常量(声明时必须<br>
指定常量值)。</p>
<h2 id="5对象的上转型对象">5.对象的上转型对象</h2>
<pre><code class="language-java">public class Animal {
  
  public void eat(){
    System.out.println(&quot;animal eatting...&quot;);
  }
}
class Bird extends Animal{
  
  public void eat(){
    System.out.println(&quot;bird eatting...&quot;);
  }
  
  public void fly(){
    
    System.out.println(&quot;bird flying...&quot;);
  }
}
class Main{
  
  public static void main(String[] args) {
    
    Animal b=new Bird(); //向上转型
    b.eat(); 
    //! error: b.fly(); b虽指向子类对象，但此时丢失fly()方法
    dosleep(new Male());
    dosleep(new Female());
  }
  
  public static void dosleep(Human h) {
    h.sleep();
  }
}
</code></pre>
<p>◆上转型对象可以代替子类对象去调用子类重写的实例方法。如果子类重写的方法是实例方法，那么上转型对象调用重写的方法时，就是通知对应的子类对象去调用这些方法。因此，如果子类重写了父类的某个实例方法后，子类对象的上转型对象调用这个方法时，一定是调用了这个重写的方法。</p>
<p>◆上转型对象可以调用子类继承的成员变量和隐藏的成员变量。<br>
<a href="https://postimg.cc/1nQJ8wfp"><img src="https://i.postimg.cc/hjJw30n3/IMG-20190322-203800.jpg" alt="IMG-20190322-203800.jpg"></a><br>
<br><br>
<a href="https://postimg.cc/zbFpKvg4"><img src="https://i.postimg.cc/76pcvTYP/IMG-20190322-203810.jpg" alt="IMG-20190322-203810.jpg"></a></p>
<br>
> 本文作者: 韩宇  
本文链接: <http://stevenhy.com/post/2019-3-22-java-class-and-extends/>
版权声明: 本博客所有文章除特别声明外, 均采用[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议, 转载请注明出处]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python ccf题解 201809-1 卖菜]]></title>
        <id>http://stevenhy.com/post/2019-2-28-ccf-csp-maicai</id>
        <link href="http://stevenhy.com/post/2019-2-28-ccf-csp-maicai">
        </link>
        <updated>2019-02-12T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>python ccf题解 201809-1 卖菜</p>
]]></summary>
        <content type="html"><![CDATA[<p>python ccf题解 201809-1 卖菜</p>
<!-- more -->
<p>问题描述</p>
<p>在一条街上有n个卖菜的商店，按1至n的顺序排成一排，这些商店都卖一种蔬菜。<br><br>
　　第一天，每个商店都自己定了一个价格。店主们希望自己的菜价和其他商店的一致，第二天，每  一家商店都会根据他自己和相邻商店的价格调整自己的价格。具体的，每家商店都会将第二天的  菜价设置为自己和相邻商店第一天菜价的平均值（用去尾法取整）。<br><br>
　　注意，编号为1的商店只有一个相邻的商店2，编号为n的商店只有一个相邻的商店n-1，其他编号为i的商店有两个相邻的商店i-1和i+1。<br><br>
　　给定第一天各个商店的菜价，请计算第二天每个商店的菜价。<br></p>
<p><em><strong>输入格式</strong></em><br>
　　输入的第一行包含一个整数n，表示商店的数量。<br>
　　第二行包含n个整数，依次表示每个商店第一天的菜价。</p>
<p><em><strong>输出格式</strong></em></p>
<p>输出一行，包含n个正整数，依次表示每个商店第二天的菜价。</p>
<p>样例输入</p>
<p>8<br>
4 1 3 1 6 5 17 9</p>
<p>样例输出</p>
<p>2 2 1 3 4 9 10 13</p>
<p>数据规模和约定</p>
<p>对于所有评测用例，2 ≤ n ≤ 1000，第一天每个商店的菜价为不超过10000的正整数。</p>
<pre><code class="language-python"># 卖菜
# 输入
n = int(input())
a = list(map(int, input().split()))
b = []
# 计算第二天菜价
for i in range(n):
  if(i == 0):
      b.append((a[0] + a[1]) // 2)
  elif(i == n - 1):
      b.append((a[-2] + a[-1]) // 2)
  else:
      b.append((a[i - 1] + a[i] + a[i + 1]) // 3)
# 输出
print(&quot; &quot;.join(map(str, b)))
</code></pre>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/2019-2-28-ccf-csp-maicai/">http://stevenhy.com/post/2019-2-28-ccf-csp-maicai/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
</feed>