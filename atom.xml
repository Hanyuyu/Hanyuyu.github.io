<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://stevenhy.com</id>
    <title>stevenhy&apos;s pocket</title>
    <updated>2019-10-13T13:23:38.123Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://stevenhy.com"/>
    <link rel="self" href="http://stevenhy.com/atom.xml"/>
    <subtitle>玻璃明亮, 橘子辉煌</subtitle>
    <logo>http://stevenhy.com/images/avatar.png</logo>
    <icon>http://stevenhy.com/favicon.ico</icon>
    <rights>All rights reserved 2019, stevenhy&apos;s pocket</rights>
    <entry>
        <title type="html"><![CDATA[Java类加载器]]></title>
        <id>http://stevenhy.com/post/gaQfofbzk</id>
        <link href="http://stevenhy.com/post/gaQfofbzk">
        </link>
        <updated>2019-09-07T01:34:10.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="一段java代码从编写完毕到成功执行-这之间到底经历了什么过程">一段java代码从编写完毕到成功执行, 这之间到底经历了什么过程?</h3>
<h3 id="其中又运行着哪些机制嘞">其中又运行着哪些机制嘞?</h3>
]]></summary>
        <content type="html"><![CDATA[<h3 id="一段java代码从编写完毕到成功执行-这之间到底经历了什么过程">一段java代码从编写完毕到成功执行, 这之间到底经历了什么过程?</h3>
<h3 id="其中又运行着哪些机制嘞">其中又运行着哪些机制嘞?</h3>
<!-- more -->
<p><a href="https://www.cnblogs.com/wang-meng/p/5574071.html">原文链接, 作者写的太棒了!</a></p>
<p>一、问题</p>
<p>请新建如下类，并运行它：</p>
<pre><code class="language-java">1 package java.lang;
2 
3 public class Long {
4     public static void main(String[] args) {
5         System.out.println(&quot;Hi, i am here&quot;);
6     }
7 }
</code></pre>
<p><strong>你能猜到它的运行如果吗？ 不错，就是如下这个样子！</strong></p>
<pre><code class="language-java">错误: 在类 java.lang.Long 中找不到 main 方法, 请将 main 方法定义为:
public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application
</code></pre>
<p>为什么呢，明明我在Long方法类中定义了main方法，为什么说main方法没有定义呢？</p>
<p>本文将解决以上问题出现的原因。</p>
<p>二、ClassLoader的作用</p>
<p>我们都知道java程序写好以后是以.java（文本文件）的文件存在磁盘上，然后，我们通过(bin/javac.exe)编译命令把.java文件编译成.class文件（字节码文件），并存在磁盘上。但是程序要运行，首先一定要把.class文件加载到JVM内存中才能使用的，我们所讲的classLoader,就是负责把磁盘上的.class文件加载到JVM内存中，如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="http://stevenhy.com/post-images/1567820465126.png" alt=""></figure>
<p>你可以认为每一个Class对象拥有磁盘上的那个.class字节码内容,每一个class对象都有一个getClassLoader()方法，这个方法会让你知道是谁把我从.class文件加载到内存中变成Class对象的(因为不止一个classloader可以把类加载到内存中)。</p>
<p>三、ClassLoader层次结构</p>
<p>请执行如下程序：</p>
<pre><code class="language-java"> 1 public class Test {
 2     public static void main(String[] args) {
 3         ClassLoader classLoader = Test.class.getClassLoader();
 4         System.out.println(classLoader);
 5         
 6         ClassLoader classLoader1 = classLoader.getParent();
 7         System.out.println(classLoader1);
 8         
 9         ClassLoader classLoader2 = classLoader1.getParent();
10         System.out.println(classLoader2); 
11     }
12 }
</code></pre>
<p>它的输出是：</p>
<pre><code class="language-java">sun.misc.Launcher$AppClassLoader@2a139a55
sun.misc.Launcher$ExtClassLoader@7852e922
null
</code></pre>
<p>classLoader2是null值。因为总共就有三个类加载器:</p>
<p>(1): 根类加载器(null)--**爷爷👴</p>
<p>它是由本地代码(c/c++)实现的，你根本拿不到他的引用，但是他实际存在，并且加载一些重要的类，它加载(%JAVA_HOME%\jre\lib),如rt.jar(runtime)、i18n.jar等，这些是Java的核心类。</p>
<p>(2): 扩展类加载器(ExtClassLoader)--**爹👨</p>
<p>虽说能拿到，但是我们在实践中很少用到它，它主要加载扩展目录下的jar包， %JAVA_HOME%\lib\ext</p>
<p>(3): 应用类加载器(AppClassLoader)--**你👶</p>
<p>它主要加载我们应用程序中的类，如Test,或者用到的第三方包,如jdbc驱动包等。</p>
<p>**这里的父类加载器与类中继承概念要区分，它们在class定义上是没有父子关系的。</p>
<p>四、Class加载时调用类加载器的顺序</p>
<p>当一个类要被加载时，有一个启动类加载器和实际类加载器的概念，这个概念请看如下分析</p>
<p>如上面的Test.class要进行加载时，它将会启动应用类加载器进行加载Test类，但是这个应用类加载器不会真正去加载他，而是会调用看是否有父加载器，结果有，是扩展类加载器，扩展类加载器也不会直接去加载，它看自己是否有父加载器没，结果它还是有的，是根类加载器。</p>
<p>所以这个时候根类加载器就去加载这个类，可在%JAVA_HOME%\jre\lib下，它找不到com.wangmeng.Test这个类，所以他告诉他的子类加载器，我找不到，你去加载吧，子类扩展类加载器去%JAVA_HOME%\lib\ext去找，也找不着，它告诉它的子类加载器 AppClassLoader，我找不到这个类，你去加载吧，结果AppClassLoader找到了，就加到内存中，并生成Class对象。<br>
这个时间时候启动类加载器（应用类加载器）和实际类加载器（应用类加载器）是同一个.</p>
<p>这就是Java中著名的委托加载机制，看如下图：</p>
<figure data-type="image" tabindex="2"><img src="http://stevenhy.com/post-images/1567820814324.jpg" alt=""></figure>
<p>我们再来看一下 java.lang.Long的加载，按上面分析，应该是由根类加载器加载得到的，此时启动类加载器是应用类加载器，但实际类加载器是根类加载器。</p>
<p>所以回到我们最开始那个问题，没有main方法是因为执行的根本不是我们自己写的类，执行的是java核心中的那个Long类，当然没有main方法了。 这样就防止我们应用中写的类覆盖掉java核心类。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反射]]></title>
        <id>http://stevenhy.com/post/2-tqcbh4i</id>
        <link href="http://stevenhy.com/post/2-tqcbh4i">
        </link>
        <updated>2019-09-02T05:23:00.000Z</updated>
        <summary type="html"><![CDATA[<p>java中反射机制 是框架的灵魂所在, 反射可以将类的各个组成部分封装为其他对象, 这样做的好处有两个, 一是可以在程序的运行过程中操作这些对象, 二是可以解耦, 以提高程序的可扩展性.</p>
]]></summary>
        <content type="html"><![CDATA[<p>java中反射机制 是框架的灵魂所在, 反射可以将类的各个组成部分封装为其他对象, 这样做的好处有两个, 一是可以在程序的运行过程中操作这些对象, 二是可以解耦, 以提高程序的可扩展性.</p>
<!-- more -->
<p>java类对象从创建到运行,一共会经历三个阶段.</p>
<ol>
<li>第一阶段: 源代码构建阶段, 在代码构建好后会是一个**.java文件, 在运行之前,需要借助javac进行编译, 编译之后会生成对应的**.class 字节码文件, 在这个字节码文件中封装了之前定义类中的, 成员变量, 构造方法, 成员方法.</li>
<li>第二阶段: 加载进内存阶段: 在定义与调用之间的一个阶段, 在这个阶段中, java中的类加载器会把在第一个阶段生成的字节码文件加载进内存, 并封装为一个class类对象.</li>
<li>第三阶段: 运行时阶段, 这个阶段是经常看到的, 即创建实例对象, 调用方法等.</li>
</ol>
<h3 id="获取class对象的方式">获取Class对象的方式</h3>
<p>同样获取Class对象有三种方式, 对应着java对象经历的三个阶段:</p>
<ol>
<li>Class.forName(&quot;全类名&quot;): 当类还没有加载进内存的时候, 可以调用该方法, 返回一个class对象, 这一方法多用于配置文件的方法中, 先将类名定义在配置文件中,然后读取配置文件, 加载类.</li>
</ol>
<pre><code class="language-java">    //1.加载配置文件
    //1.1创建Properties对象
    Properties pro = new Properties();
    //1.2加载配置文件，转换为一个集合
    //1.2.1获取class目录下的配置文件
    ClassLoader classLoader = ReflectTest.class.getClassLoader();
    InputStream is = classLoader.getResourceAsStream(&quot;pro.properties&quot;);
    pro.load(is);

    //2.获取配置文件中定义的数据
    String className = pro.getProperty(&quot;className&quot;);
    String methodName = pro.getProperty(&quot;methodName&quot;);


    //3.加载该类进内存
    Class cls = Class.forName(className);
    //4.创建对象
    Object obj = cls.newInstance();
    //5.获取方法对象
    Method method = cls.getMethod(methodName);
    //6.执行方法
    method.invoke(obj);
</code></pre>
<p>这段程序完成了一个功能, 即创建任意类对象并执行任意方法, 相关类与方法需要提供配置文件.<br>
2. 类名.class: 通过类名的属性class获取, 多用于参数的传递<br>
3. 对象.getClass(): 这个方法在Object类中定义着, 意味着所有的对象均有该方法<br>
**注意: 同一个字节码文件(*.class)在一次程序运行的过程中只会被加载一次, 无论是哪一种方式获取的class对象都是同一个</p>
<h3 id="class对象的功能">class对象的功能</h3>
<p>*Class对象功能：</p>
<ol>
<li>
<p>获取成员变量们<br>
* Field[] getFields() ：获取所有public修饰的成员变量<br>
* Field getField(String name)   获取指定名称的 public修饰的成员变量<br><br>
* Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符<br>
* Field getDeclaredField(String name)</p>
</li>
<li>
<p>获取构造方法们<br>
* Constructor&lt;?&gt;[] getConstructors()<br>
* Constructor<T> getConstructor(类&lt;?&gt;... parameterTypes)  <br><br>
* Constructor<T> getDeclaredConstructor(类&lt;?&gt;... parameterTypes)<br>
* Constructor&lt;?&gt;[] getDeclaredConstructors()</p>
</li>
<li>
<p>获取成员方法们：<br>
* Method[] getMethods()<br>
* Method getMethod(String name, 类&lt;?&gt;... parameterTypes)  <br><br>
* Method[] getDeclaredMethods()<br>
* Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</p>
</li>
<li>
<p>获取全类名	<br>
* String getName()</p>
</li>
</ol>
<!-- more -->
<h3 id="各个封装类的方法">各个封装类的方法</h3>
<pre><code>	* Field：成员变量
	* 操作：
		1. 设置值
			* void set(Object obj, Object value)  
		2. 获取值
			* get(Object obj) 

		3. 忽略访问权限修饰符的安全检查
			* setAccessible(true):暴力反射

* Constructor:构造方法
	* 创建对象：
		* T newInstance(Object... initargs)  

		* 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法


* Method：方法对象
	* 执行方法：
		* Object invoke(Object obj, Object... args)  

	* 获取方法名称：
		* String getName:获取方法名</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Junit 单元测试]]></title>
        <id>http://stevenhy.com/post/HlZOD_F9N</id>
        <link href="http://stevenhy.com/post/HlZOD_F9N">
        </link>
        <updated>2019-09-02T05:04:44.000Z</updated>
        <summary type="html"><![CDATA[<p>Junit 单元测试的知识点总结及要点归纳</p>
]]></summary>
        <content type="html"><![CDATA[<p>Junit 单元测试的知识点总结及要点归纳</p>
<!-- more -->
<h2 id="单元测试分类">单元测试分类</h2>
<ol>
<li>黑盒测试: 不需要写代码,即不关注程序的内部流程 给输入值, 看程序是否能够输出期望的值</li>
<li>白盒测试: 更加关注程序的内部流程.是我重点要讨论总结的</li>
</ol>
<h2 id="白盒测试">白盒测试</h2>
<ul>
<li>步骤
<ol>
<li>定义一个测试类(被测试的类名+Test), 并且为测试建立一个单独的package放在与被测试类的包同级的目录下</li>
<li>定义测试方法,这里的方法是可以独立运行的, 不过要记得在方法上面添加@Test注释, 并且导入Junit包才可以独立运行</li>
<li>一般测试的时候, 如果已经实现知道了会有一个确定的结果, 则可以通过断言操作来判断测试是否通过<strong>Assert.assertEquals(期望值, 运算值)</strong></li>
<li>如果测试通过,则会显示绿色, 否则结果为红色</li>
</ol>
</li>
</ul>
<h2 id="相关补充">相关补充</h2>
<ul>
<li>@Before
<ul>
<li>所有被Before注释的方法会在测试方法前先被执行</li>
</ul>
</li>
<li>@After
<ul>
<li>所有被After注释的方法会在测试方法完成之后先被执行</li>
</ul>
</li>
</ul>
<!-- more -->
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/HlZOD_F9N/">http://stevenhy.com/post/HlZOD_F9N/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[以递归之名 - 重构二分搜索树]]></title>
        <id>http://stevenhy.com/post/C3wLDTZD3</id>
        <link href="http://stevenhy.com/post/C3wLDTZD3">
        </link>
        <updated>2019-08-18T01:37:45.000Z</updated>
        <summary type="html"><![CDATA[<p>回顾二叉树和二分搜索树, 顺便见识一下递归的魅力!💥</p>
]]></summary>
        <content type="html"><![CDATA[<p>回顾二叉树和二分搜索树, 顺便见识一下递归的魅力!💥</p>
<!-- more -->
<h1 id="定义">定义</h1>
<p><strong>树的基本概念：</strong><br>
1、结点：树中的数据元素都称之为结点<br>
2、根：最上面的结点称之为根，一颗树只有一个根且由根发展而来，从另外一个角度来说，每个结点都可以认为是其子树的根<br>
3、父亲：结点的上层结点<br>
4、兄弟：具有相同父亲的结点称为兄弟<br>
5、结点的度：结点所拥有的子树的个数称之为结点的度<br>
6、树叶：度为0的结点，也叫作终端结点<br>
7、分支结点：度不为0的结点，也叫作非终端结点或内部结点<br>
8、结点的层次：从根节点到树中某结点所经路径上的分支树称为该结点的层次，根节点的层次规定为1，其余结点的层次等于其父亲结点的层次+1<br>
9、树的深度：树中结点的最大层次数</p>
<blockquote>
<p>参考原文链接：<a href="https://blog.csdn.net/weixin_39723544/article/details/83279605">https://blog.csdn.net/weixin_39723544/article/details/83279605</a></p>
</blockquote>
<p><strong>二叉树</strong><br>
其每一个结点不能多余两个子结点。是一种动态的数据结构。查找的平均复杂度是O(logN)，当然在最坏的情况下，就是一个类似链表的结构。<br>
二叉树与链表一样具有天然的递归结构，其左右子树也是二叉树，此外，二叉树不一定是满的，只有一个节点也可以成为二叉树，空也是一颗二叉树</p>
<p><strong>二分搜索树</strong><br>
一个二叉树是二分搜索树需要以下条件：</p>
<ul>
<li>二分搜索树是二叉树</li>
<li>对于二分搜索树每个结点的值：大于其左子树所有节点的值，小于其右子树所有节点的值。(这是今天要回顾的重点，但是这样的定义使得我们的二分搜索树中不包含重复元素，如果想要包含重复元素，可改定义)</li>
<li>其每一个子树也是二分搜索树</li>
<li>存储的结点必须有可比较性</li>
</ul>
<h1 id="构造二分搜索树类并添加方法">构造二分搜索树类并添加方法</h1>
<p>先规划我们的二分搜索树中要实现的功能：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>size()</td>
<td>返回树中元素的个数</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>判断该树是否为空，空时返回true</td>
</tr>
<tr>
<td>add(E e)</td>
<td>再树中添加元素e (递归实现)</td>
</tr>
<tr>
<td>contains(E e)</td>
<td>查看树中是否包含e，包含返回true(递归实现)</td>
</tr>
<tr>
<td>preOrder()</td>
<td>前序遍历(递归实现)</td>
</tr>
<tr>
<td>inOrder()</td>
<td>中序遍历(递归实现)</td>
</tr>
<tr>
<td>postOrder()</td>
<td>后序遍历(递归实现)</td>
</tr>
<tr>
<td>preOrderNR</td>
<td>前序遍历(非递归),借助栈</td>
</tr>
<tr>
<td>levelOrder</td>
<td>层序遍历(非递归),借助队列</td>
</tr>
<tr>
<td>minnum()</td>
<td>找到最小值,并返回值(递归实现)</td>
</tr>
<tr>
<td>removemin()</td>
<td>删除最小值,并返回值(递归实现)</td>
</tr>
<tr>
<td>maxnum()</td>
<td>找到最大值,并返回值(递归实现)</td>
</tr>
<tr>
<td>removemax()</td>
<td>删除最大值,并返回值(递归实现)</td>
</tr>
<tr>
<td>remove(E e)</td>
<td>删除任意一个结点(递归实现)</td>
</tr>
</tbody>
</table>
<p><strong>Coding Now</strong></p>
<h3 id="1开始构建bst类的成员变量即构造方法">1.开始构建BST类的成员变量即构造方法</h3>
<pre><code class="language-java">public class BST&lt;E extends Comparable&lt;E&gt;&gt; {
	private class Node{
		public E e;
		public Node left,right;
		
		public Node(E e) {
			this.e = e;
			left = null;
			right = null;
		}
	}
	
	private Node root;
	private int size;
	
	public BST() {
		root = null;
		size = 0;
	
	}
}
</code></pre>
<h3 id="2添加size和isempty方法">2.添加size和isEmpty方法</h3>
<pre><code class="language-java">  //添加方法
	//1.size方法,返回树中元素个数
	public int size() {
		return size;
	}
	
	//2.isEmpty方法,判断树中是否为空
	public boolean isEmpty() {
		return size==0;
	}
</code></pre>
<h3 id="3编写add方法-向树中添加元素e要求添加后的树仍满足二分搜索树的一切条件">3.编写add方法, 向树中添加元素e,要求添加后的树仍满足二分搜索树的一切条件</h3>
<pre><code class="language-java">	public void add(E e) {
   	if(root == null) {
   		root = new Node(e);
   		size ++;
   	}
   	else
   		add(root, e);
   }
   private void add(Node node, E e) {
   	
   	//1.处理终止条件
   	if(e.compareTo(node.e)&gt;0 &amp;&amp; node.right == null) {
   		node.right = new Node(e);
   		size ++;
   		return; 
   	}
   	else if(e.compareTo(node.e)&lt;0 &amp;&amp; node.left == null) {
   		node.left = new Node(e);
   		size ++;
   		return;
   	}
   	else if(e.compareTo(node.e)==0)
   		return;
   	
   	//2.递归实现
   	if(e.compareTo(node.e) &lt; 0)
   		add(node.left, e);
   	else
   		add(node.right, e);
   	
   }
</code></pre>
<p>为什么需要一个另写一个private方法呢? 用户调用的时候并不知道这个结点要往哪里加, 但是递归需要每个结点都执行一遍, 我们需要一个Node参数, 表示从哪个结点开始执行. 但是上面的方案还是较为冗余, 原因是并没有把终止条件最小化 .<br>
在上面的终止条件有很多, 但都是表达一个意思: 在二叉树为空(空也是一个二叉树)的时候建立一个结点,并赋值为e, 至于这个新建的二叉树(目前只有一个结点) 是左节点还是右节点, 这完全是第二部分的递归控制语句来管理的.<br>
此时, 我已经把递归机制理解为一种严格的等级制度, 上下级关系明确.第一部分的终止条件起的作用是<strong>下情上达</strong> 上级的事情交代给下级来办, 这样一级一级的传下去. 最小的一级则是最终的处理者, 负责下情上达, 那么第二部起的作用呢 就是<strong>上情下达</strong> 明确控制了在什么情况下要把什么事情交给哪个下属去做. 其实只需把自己想成皇上, 把事情交给合适的大臣去办就可以了.😂<br>
有了结果控制语句和过程控制语句, 使的整个处理过程有条不紊, 效果非常理想!👍</p>
<p>改进后的add方法:</p>
<pre><code class="language-java">	//3.改进后的add方法
	public void add(E e) {
		root = add(root, e);
	}
	private Node add(Node node, E e) {
		
		//1.下情上达
		if(node == null) {
			node = new Node(e);
			size ++;
			return node;
		}
		//2.上情下达
		if(e.compareTo(node.e) &lt; 0)
			node.left = add(node, e);
		else if(e.compareTo(node.e)&gt;0)
			node.right = node.right;
		
		return node; // 此时的node已经变成处理完一切事情的node
	}
</code></pre>
<h3 id="4contains方法递归实现">4.contains方法递归实现</h3>
<pre><code class="language-java">public boolean contains(E e) {
		return contains(root, e);
	}
	private boolean contains(Node node, E e) {
		//1.终止条件
		if(node == null) {
			return false;
		}
		
		//2.递归方式
		if(e.compareTo(node.e)==0)
			return true;
		else if(e.compareTo(node.e)&lt;0)
			return contains(node.left, e);
		else
			return contains(node.right, e);
	}
</code></pre>
<h3 id="5前中后序遍历的递归实现">5.前中后序遍历的递归实现</h3>
<pre><code class="language-java">	public void preOrder() {
		preOrder(root);
	}
	private void preOrder(Node node) {
		if(node == null)
			return;
		//访问体
		System.out.println(node.e);
		preOrder(node.left);
		preOrder(node.right);
	}
	
	public void inOrder() {
		inOrder(root);
	}
	private void inOrder(Node node) {
		if(node == null)
			return;
		inOrder(node.left);
		//访问体
		inOrder(node.right);
	}
	
	public void postOrder() {
		postOrder(root);
	}
	private void postOrder(Node node) {
		if(node == null)
			return;
		postOrder(node.left);
		postOrder(node.right);
		//访问体
		System.out.println(node.e);
	}
</code></pre>
<h3 id="6前序遍历的非递归实现">6.前序遍历的非递归实现</h3>
<p>二叉树遍历的非递归实现要比递归实现复杂, 道理也很简单,交给下级去办事总比自己办事要容易的多. 如何实现非递归的前序遍历呢? 前序遍历的原理是对于每一个结点, 按照父-左-右的顺序去遍历, 这个顺序是固定的所以我们可以借助队列来完成.<br>
先让父节点入栈, 然后出栈处理父节点, 让其右结点和左结点相继进栈(因为先处理左结点所以先让右结点进栈)处理完父结点后下一个元素出栈即左结点出栈, 开始处理左结点, 让左结点的右结点和左结点进栈, 循环往复, 知道无再入栈元素且栈为空.则遍历完毕. 这时候你可能会想, 是如何想到拿栈来解决问题的呢? 那之前的队列为啥不行呢? 仔细想一下便知, 栈的特点是出栈的顺序与进栈顺序是没有关系的, 而队列, 出队的顺序与进队的顺序是一致的,回想前面的解决方案, 我们先让右结点进栈再让左结点进栈, 在处理左结点的时候, 如果有的化会先让他的子节点进栈, 接着处理的是他的子节点, 完全没有轮到之前的右结点. 但如果是队列的话, 左结点的子节点们, 只能排在后面了. 这就无法达到我们先处理左结点在处理右结点的要求了, 理解了原理之后, 开始写代码..</p>
<pre><code class="language-java">	//前序遍历的非递归写法
	public void preOrderNR() {
		ArrayStack&lt;Node&gt; stack = new ArrayStack&lt;Node&gt;();
		stack.push(root);
		while(!stack.isEmpty()) {
			Node node = stack.pop();
			System.out.println(node.e);
			if(node.right!=null)
				stack.push(node.right);
			if(node.left!=null)
				stack.push(node.left);
		}
	}
</code></pre>
<p>我们也可以借助之前实现的栈来进行, 效果也是一样的</p>
<h3 id="7层序遍历-意思是一层一层的从左往右遍历">7.层序遍历, 意思是一层一层的从左往右遍历</h3>
<p>和上面的前序遍历比较一下, 前序遍历是要在处理右结点之前要处理完左结点的所有. 所以使用了栈来控制处理节点的顺序, 而层序遍历强调的是一层处理完再处理下一层, 正好用到我们的队列.在左结点还有子节点的时候, 处理完左结点之后要先把右结点处理了. 正好用到了队列, 还不理解的话看完代码就懂了</p>
<pre><code class="language-java">	//层序遍历,queue需要特定的类型接口,这里我们用LinkedList的接口
	public void levelOrder() {
		Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;();
		q.add(root);
		while(!q.isEmpty()) {
			Node cur = q.remove();
			System.out.println(cur.e);
			if(cur.left!=null)
				q.add(cur.left);
			if(cur.right!=null)
				q.add(cur.right);
		}
		
	}
</code></pre>
<h3 id="8查找最值">8.查找最值</h3>
<p>先来写找到最小值与最大值并返回(E类型),依然是递归实现, 这没有啥好说的</p>
<pre><code class="language-java">	//找到最小值
	public E minnum() {
		if(size == 0)
			throw new IllegalArgumentException(&quot;Bst is Empty&quot;);
		return minnum(root).e;
	}
	private Node minnum(Node node) {
		if(node.left == null)
			return node;
		return minnum(node.left);
	}
	
	//找到最大值
	public E maxnum() {
		if(size == 0)
			throw new IllegalArgumentException(&quot;Bst is Empty&quot;);
		return maxnum(root).e;
	}
	private Node maxnum(Node node) {
		if(node.right == null)
			return node;
		return maxnum(node.right);
	}
</code></pre>
<h3 id="9删除最小值与最大值并返回该值-这个返不返回无所谓-从用户角度来看-告诉用户你删除了哪个值可能更好一些">9.删除最小值与最大值,并返回该值, 这个返不返回无所谓, 从用户角度来看, 告诉用户你删除了哪个值可能更好一些</h3>
<p>如何删除, 对于最小值来说, 这个结点一定是一个左结点,而且只有两种情况, 一是只有右孩子, 二是没有孩子,是一个叶子结点. 针对叶子结点的情况没什么好说的,删除即可, 对于第一种情况就是用右孩子替换自身即可, 这是你的手下要办的事情, 现在你需要做的是把宰相叫过来, 把命令传达下去. 至于删除最大值嘛.. 道理是一样的只不过替换的是左孩子.</p>
<pre><code class="language-java">	//删除最小值
	public E removemin() {
		E ret = minnum();  //size=0的情况已经在minnum方法中处理过了
		removemin(root);
		return ret;
	}
	//返回删除后的新根
	private Node removemin(Node node) {
		if(node.left == null) {
			Node rightNode = node.right;
			node.right = null;
			size --;
			return rightNode;
		}
		
		node.left = removemin(node.left);
		return node;
	}
	
	//删除最大值
	public E removemax() {
		E ret = maxnum();  //size=0的情况已经在maxnum方法中处理过了
		removemax(root);
		return ret;
	}
	//返回删除后的新根
	private Node removemax(Node node) {
		if(node.right==null) {
			Node leftNode = node.left;
			node.left = null;
			size --;
			return leftNode;
		}
		
		node.right = removemax(node.right);
		return node;
	}
</code></pre>
<h3 id="10删除结点值为e的结点">10.删除结点值为e的结点</h3>
<p>如何去删除这样一个任意的结点呢?(这里的任意指的是不像最小值一样可以确定它是一个左结点), 这就需要我们分情况讨论了, 如果这个结点只有左孩子, 处理方法与我们在删除最大结点的方法是一样的, 就是让它的左结点去代替它, 如果这个结点只有右孩子, 处理方法则和删除最小结点时是一样的, 即用右孩子来代替它. 如果这个结点没有孩子嘞? 其实这个根本不用单独管他, 因为我们前两种情况任意一个就包含他了. 真正头疼的是左右孩子都有的情况, 处理这种情况需要用到Hibbard Deletion 算法, 即找到比要删除结点大的最小结点来代替它, 这道理很简单, 二分搜索树本就是一个有序序列(中序),就像1 2 3 4 5,删除3, 代替他位置的可以是2也可以是4, 所以也可以是比这个结点小的最大结点来代替. 非常清晰, 这里我们采用后驱代替的方式</p>
<pre><code class="language-java">	//删除值为e的结点,这个就不需要返回值了,用户已经知道他要删什么了
	public void remove(E e) {
		root = remove(root, e);
	}
	private Node remove(Node node, E e) {
		//先找到那个结点
		if(node == null)
			return null;
		if(e.compareTo(node.e)&lt;0) {
			node.left = remove(node.left, e);
			return node;
		}
		else if(e.compareTo(node.e)&gt;0) {
			node.right = remove(node.right, e);
			return node;
		}
		else {//e.compareTo(node.e)==0
			//此时结点已找到,按之前讨论的三种方案执行
			//1.只有右结点
			if(node.left == null) {
				Node rightNode = node.right;
				node.right = null;
				size --;
				return rightNode;
			}
			//2.只有左结点
			if(node.right == null) {
				Node leftNode = node.left;
				node.left = null;
				size --;
				return leftNode;
			}
			//3.左右结点都有,用Hibbard Deletion算法
			Node successor = minnum(node.right); //拿到了代替结点即后继
			successor.right = removemin(node.right); //此时该后继已经拽住了待删除节点的右子树
			//但是经历过removemin操作size会减一,但此时被remove的那个结点(即后继)到了上面,整体并没有少
			size ++;
			successor.left = node.left;
			//此时,后继结点又拽住了待删节点的左子树, 后继是时候代替它了
			size --;
			return successor; //替换完毕,node变为successor,操作结束.
		}
	}
</code></pre>
<h1 id="总结一下">总结一下</h1>
<p>到这里, 整个二分搜索树就已经构造完毕了, 感觉自己的递归能力又强了一点😄<br>
还有一些需要记录的知识就是前中后序遍历中：<br>
前序+中序<br>
后序+中序<br>
只有这两种方式可以唯一确定一颗二叉树，为什么前序+后序不可以呢，从原理上看一下 前序是：<strong>中左右</strong>， 后序是：<strong>左右中</strong>，一旦<strong>左右</strong>有一个是缺失的那么你就无法确定和<strong>中</strong>挨在一起的是<strong>左</strong>还是<strong>右</strong>，因为空(null)是不会显示的，所以你也就知道了，如果是一个满的二叉树那么前序和后序也是可以确定的。<br>
洋洋洒洒三千字，今天先歇了😴<br>
<br></p>
<hr>
<p><strong>推荐阅读</strong></p>
<p><a href="http://stevenhy.com/post/9KuaIONib1/">深入理解递归的运行机制</a></p>
<hr>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/C3wLDTZD3/">http://stevenhy.com/post/C3wLDTZD3/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解递归的运行机制]]></title>
        <id>http://stevenhy.com/post/9KuaIONib1</id>
        <link href="http://stevenhy.com/post/9KuaIONib1">
        </link>
        <updated>2019-08-14T04:15:52.000Z</updated>
        <summary type="html"><![CDATA[<p>🙋‍♂️这一篇主要理一理关于递归的那些事儿, 顺便给之前的LeetCode 203题做个小结.</p>
]]></summary>
        <content type="html"><![CDATA[<p>🙋‍♂️这一篇主要理一理关于递归的那些事儿, 顺便给之前的LeetCode 203题做个小结.</p>
<!-- more -->
<h2 id="引入递归">引入递归</h2>
<p>递归调用是有代价的，体现在函数调用+系统栈空间 。<br>
如果不处理那个最小的事件单元， 那么递归是不会有返回值的，<br>
递归将一直进行下去，占满系统栈空间，导致程序崩溃<br>
当然如果递归次数过多， 系统栈也会同样被占满。</p>
<p>说起递归，它的原理和我们之前讲过的栈的一个应用十分类似，就是子程序调用的过程，深入递归内部，实现过程是一样的，所以会存在系统栈这一说法。<br>
<img src="http://stevenhy.com/post-images/1565760791060.png" alt=""></p>
<p>这里提一道简单的题目，给定一个int数组，我们把数组内所有元素的和求出来.<br>
用递归的思想来解决<br>
编写的sum函数接受两个参数, arr是要计算的数组变量,l是一个索引标识, 函数的功能是计算arr中[ l,n )的元素和</p>
<pre><code class="language-java">public static void main(String[] args){
		public sum(int[] arr, int l) {
				if(l == arr.length)
						return 0;
				return arr[0] + sum(arr, l+1);
		}
}
</code></pre>
<p>我们来看一下递归函数在执行过程中的原理图<br>
<img src="http://stevenhy.com/post-images/1565759980401.png" alt=""></p>
<h2 id="深入分析">深入分析</h2>
<p>从上面的分析, 我们可以知晓递归的具体实现过程. 至于面对一个递归问题, 如何分析出解决代码, 其实也是有章可循的。🤪<br>
在这里我总结一个方法：</p>
<ul>
<li>找到最小问题单元，实现返回值。</li>
<li>把比原问题小一级的问题答案当作已知，去解决大问题。</li>
</ul>
<p>这样说起来，可能比较抽象，我来分布讲解一下：</p>
<ol>
<li>对第一步的理解，我们可以参考上面求和一题，大问题是数组中每个元素求和，就是<strong>和(arr[0]~arr[n])</strong>, 按照递归的思想，这个大问题可以转化为 <strong>arr[0]+和(arr[1]~arr[n])</strong>, 那么现在<strong>和(arr[1]~arr[n])</strong> 就成了我们的新问题，同时这个新问题就是比原问题小一级的问题，换句话说，我们只要解决了这个新问题，那原问题便可迎刃而解。为了方便之后描述，我们暂且把这个新问题称为1号问题。<br>
那如何解决1号问题呢？同理，我们还需要解决2号问题就是比1号问题还要小一级的问题，<strong>和(arr[2]~arr[n])</strong> ,解决了2号问题，加个arr[1]，就可以解决我们的1号问题，那么也就解决了我们的原问题。你可以看到，我们要解决的问题都是一些同类型的问题。那么相当于2号问题还会有3号问题，4号问题等等等等。如果数组中有n个元素，最后元素的下标是(n-1),我们的第n-1号问题便是<strong>和([])</strong><br>
这就是最小的问题，这个最小问题是我们可以解决的，一个空数组的和当然是0了<br>
当计算到第n-1号问题时，函数中依然会调用sum(arr,n)而程序中没有索引为n的元素，意味着已经计算到了最小的问题，所以添加判断，当此时传入的n等于数组长度时，返回最小单元的值。解决了最小单元所有的问题便迎刃而解。这就时原理上我们为什么需要去解决这一问题，返回最小问题单元的解，这便是第一步。</li>
<li>第一步做好之后，我们只是返回了最小问题单元的值，要完成递归过程，我们还得让程序可以走到最小的问题单元，这便是递归。此时要站在原问题的角度，把1号问题的结果当作已知去解决我们的大问题。<code>return arr[0] + sum(arr, l+1);</code><br>
便是这个意思。</li>
</ol>
<h2 id="扩展练习">扩展练习</h2>
<p><a href="http://stevenhy.com/post/9KuaIONib/">之前有练习过一道LeetCode链表题，我提到了三种解法</a>，题目是给一个链表的头节点，和一个val值，要求删除链表中值为val的节点，最后返回删除好的链表的头节点。<br>
这里再贴一下当时的递归解法：</p>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null) return null;
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
		}
}
</code></pre>
<p>贴一下这个递归解法的图解操作：<br>
<img src="http://stevenhy.com/post-images/1565760505529.png" alt=""></p>
<p><img src="http://stevenhy.com/post-images/1565760687560.png" alt=""><br>
看完图解，对整个过程应该是很清楚了，如果还不了解，可以再程序中添加输出的方式，帮助理解整个过程。</p>
<pre><code class="language-java">public class Solution {

    public ListNode removeElements(ListNode head, int val, int depth) {

        String depthString = generateDepthString(depth);

        System.out.print(depthString);
        System.out.println(&quot;Call: remove &quot; + val + &quot; in &quot; + head);

        if(head == null){
            System.out.print(depthString);
            System.out.println(&quot;Return: &quot; + head);
            return head;
        }

        ListNode res = removeElements(head.next, val, depth + 1);
        System.out.print(depthString);
        System.out.println(&quot;After remove &quot; + val + &quot;: &quot; + res);

        ListNode ret;
        if(head.val == val)
            ret = res;
        else{
            head.next = res;
            ret = head;
        }
        System.out.print(depthString);
        System.out.println(&quot;Return: &quot; + ret);

        return ret;
    }

    private String generateDepthString(int depth){
        StringBuilder res = new StringBuilder();
        res.append(&quot;depth &quot;);
        res.append(depth);
        res.append(&quot; &quot;);
        for(int i = 0 ; i &lt; depth ; i ++)
            res.append(&quot;--&quot;);
        return res.toString();
    }

    public static void main(String[] args) {

        int[] nums = {1, 2, 6, 3, 4, 5, 6};
        ListNode head = new ListNode(nums);
        System.out.println(head);

        ListNode res = (new Solution()).removeElements(head, 6, 0);
        System.out.println(res);
    }

}
</code></pre>
<p><strong>运行结果如下：</strong></p>
<pre><code class="language-java">1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL
depth 0 Call: remove 6 in 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL
depth 1 --Call: remove 6 in 2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL
depth 2 ----Call: remove 6 in 6-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL
depth 3 ------Call: remove 6 in 3-&gt;4-&gt;5-&gt;6-&gt;NULL
depth 4 --------Call: remove 6 in 4-&gt;5-&gt;6-&gt;NULL
depth 5 ----------Call: remove 6 in 5-&gt;6-&gt;NULL
depth 6 ------------Call: remove 6 in 6-&gt;NULL
depth 7 --------------Call: remove 6 in null
depth 7 --------------Return: null
depth 6 ------------After remove 6: null
depth 6 ------------Return: null
depth 5 ----------After remove 6: null
depth 5 ----------Return: 5-&gt;NULL
depth 4 --------After remove 6: 5-&gt;NULL
depth 4 --------Return: 4-&gt;5-&gt;NULL
depth 3 ------After remove 6: 4-&gt;5-&gt;NULL
depth 3 ------Return: 3-&gt;4-&gt;5-&gt;NULL
depth 2 ----After remove 6: 3-&gt;4-&gt;5-&gt;NULL
depth 2 ----Return: 3-&gt;4-&gt;5-&gt;NULL
depth 1 --After remove 6: 3-&gt;4-&gt;5-&gt;NULL
depth 1 --Return: 2-&gt;3-&gt;4-&gt;5-&gt;NULL
depth 0 After remove 6: 2-&gt;3-&gt;4-&gt;5-&gt;NULL
depth 0 Return: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
</code></pre>
<p>这样就很清晰了，对递归的深度的理解也会比较到位💦</p>
<hr>
<br>
<p><strong>推荐阅读</strong></p>
<ul>
<li><a href="http://stevenhy.com/post/FiTjgJh8i">数据结构回顾 - 链表实现及应用</a></li>
<li><a href="http://stevenhy.com/post/9KuaIONib">LeetCode203 - 链表移除问题的三种解决方案</a><br>
<br></li>
</ul>
<hr>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/9KuaIONib1/">http://stevenhy.com/post/9KuaIONib1/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode203 - 链表移除问题的三种解决方案]]></title>
        <id>http://stevenhy.com/post/9KuaIONib</id>
        <link href="http://stevenhy.com/post/9KuaIONib">
        </link>
        <updated>2019-08-14T01:18:53.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode中的203题, 链表移除的三种解决方案, 借此巩固链表知识</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode中的203题, 链表移除的三种解决方案, 借此巩固链表知识</p>
<!-- more -->
<h2 id="解决方案1">解决方案1</h2>
<p>1号方案理解起来相当容易, 与之前介绍的删除节点的方法原理一致, 需要找到每个节点的前驱节点, 由于头节点没有前驱节点所以需要另行处理, 具体看解法中的注释内容.</p>
<pre><code class="language-java">/*
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //首先处理头结点需删除的条件,若头结点被删除, 那么下一个就变成了头节点
				//所以这里加了while循环用来判断每一个头结点是否需要删除
		while (head != null &amp;&amp; head.val == val) {
            ListNode delNode = head;
            head = head.next;
            delNode.next = null; 
      }
				//执行到这里头结点的删除已经完毕, 此时链表中有两种情况
				//1.链表有剩余元素
				//2.链表中全是需要删除的元素, 到此已删除完毕
				//所以需要判断, 分情况对待
        if(head == null)
            return null;
        //进入第一种情况的处理
				ListNode prev = head;
        while (prev.next != null) {
            if (prev.next.val == val) {
                ListNode delNode = prev.next;
                prev.next = delNode.next;
                delNode.next = null;
            }
            else
                prev = prev.next;
        }
        return head;
    }
}
</code></pre>
<p>提交结果:</p>
<pre><code class="language-java">√ Accepted
  √ 65/65 cases passed (2 ms)
  √ Your runtime beats 92.77 % of java submissions
  √ Your memory usage beats 66.77 % of java submissions (43.5 MB)
</code></pre>
<p>对于算法而言, 我们本身其实不需要太多顾及loietory object的问题,因为所有的内存在提交判断后都会被销毁的, 因此我们换掉几句</p>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        while(head != null &amp;&amp; head.val == val){
            head = head.next;
    }
        if(head == null)
            return head;
        
        ListNode prev = head;
        while(prev.next != null){
            if(prev.next.val == val)
                prev.next = prev.next.next;
            else
                prev = prev.next;
        }
        return head;
    }
}
</code></pre>
<p>提交后结果如下:</p>
<pre><code class="language-java">√ Accepted
  √ 65/65 cases passed (2 ms)
  √ Your runtime beats 92.77 % of java submissions
  √ Your memory usage beats 67.41 % of java submissions (43.3 MB)
</code></pre>
<h2 id="解决方案2">解决方案2</h2>
<p>就删除操作来看, 如果每个节点都有它的头结点 ,那么就非常好办了, 所以我们同样可以为头节点添加一个虚拟头结点来作为它的前驱, 这样就不需要为头结点设置独立的操作语句了.</p>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        
        ListNode dummyHead = new ListNode(-1); //这里的值没有任何意义，因为不会被访问到
        dummyHead.next = head;

        ListNode prev = dummyHead;
        while(prev.next != null){
            if(prev.next.val == val)
                prev.next = prev.next.next;
            else
                prev = prev.next;
        }
        
        return dummyHead.next;
    }
}
</code></pre>
<p>提交结果如下:</p>
<pre><code class="language-java">√ Accepted
  √ 65/65 cases passed (2 ms)
  √ Your runtime beats 92.77 % of java submissions
  √ Your memory usage beats 60.74 % of java submissions (43.9 MB)
</code></pre>
<p>👌看来这样也是可以的, 尤其和之前的解决方案相比, 代码量少了不少, 看起来更轻便.</p>
<h2 id="解决方案3">解决方案3</h2>
<p>之所以有第三种解决方案是因为链表有着天然的递归特性, 所以我们可以借此特性利用递归的方式来解决本题.具体思路如下图<br>
<img src="http://stevenhy.com/post-images/1565753207243.png" alt=""></p>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null)
            return null;
        
        ListNode res = removeElements(head.next, val);
        if(head.val == val)
            return res;
        else{
            head.next = res;
            return head;
        }
    }
}
</code></pre>
<p>提交结果如下</p>
<pre><code class="language-java">√ Accepted
  √ 65/65 cases passed (2 ms)
  √ Your runtime beats 92.77 % of java submissions
  √ Your memory usage beats 58.13 % of java submissions (44 MB)
</code></pre>
<p>这其中的语句还可以优化</p>
<pre><code class="language-java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if(head == null)
            return null;
        
        head.next = removeElements(head.next, val);
        return head.val == val ? head.next : head;
    }
}
</code></pre>
<p>提交结果如下:</p>
<pre><code class="language-java">√ Accepted
  √ 65/65 cases passed (2 ms)
  √ Your runtime beats 92.77 % of java submissions
  √ Your memory usage beats 67.23 % of java submissions (43.4 MB)
</code></pre>
<h2 id="总结">总结</h2>
<p>以上就是针对于LeetCode 203 问题的三种解决方案, 对于第三种解决方案, 我会在另一篇博文<a href="http://stevenhy.com/post/9KuaIONib1/">深入理解递归的运行机制</a><br>
详细分析, 感谢阅读!</p>
<hr>
<br>
<p><strong>推荐阅读</strong></p>
<ul>
<li><a href="http://stevenhy.com/post/9KuaIONib1">深入理解递归的运行机制</a></li>
<li><a href="http://stevenhy.com/post/FiTjgJh8i">数据结构回顾 - 链表实现及应用</a><br>
<br></li>
</ul>
<hr>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/9KuaIONib/">http://stevenhy.com/post/9KuaIONib/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构回顾 - 链表实现及应用]]></title>
        <id>http://stevenhy.com/post/FiTjgJh8i</id>
        <link href="http://stevenhy.com/post/FiTjgJh8i">
        </link>
        <updated>2019-08-13T10:03:28.000Z</updated>
        <summary type="html"><![CDATA[<p>之前我们自己编写了动态数组, 并以此实现了栈和队列,但是我们所谓的动态数组底层依然是依托于静态数组, 称其为动态是因为可以适时对容量做出控制.  今天来回顾一个非常重要的数据结构-链表. 相较于动态数组, 链表可谓是真正意义上的动态结构.</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前我们自己编写了动态数组, 并以此实现了栈和队列,但是我们所谓的动态数组底层依然是依托于静态数组, 称其为动态是因为可以适时对容量做出控制.  今天来回顾一个非常重要的数据结构-链表. 相较于动态数组, 链表可谓是真正意义上的动态结构.</p>
<!-- more -->
<h2 id="1linkedlist类的编写">1.LinkedList类的编写</h2>
<p>相较于静态数组来说, 链表最大的优势在于实现了真正的动态, 但是丧失了根据索引随机访问的能力. 但是我们学习链表的目的绝不仅限于此, 事实上链表是一种最简单的动态数据结构, 掌握好链表会为之后的更难的数据结构打好基础, 同时也有利于更深入的理解引用及递归的知识.</p>
<p>废话不多说, 开始写代码</p>
<pre><code class="language-java">public class LinkedList&lt;E&gt; {
	private class Node{
		public E e;
		public Node next;
		
		public Node(E e, Node next) {
			this.e = e;
			this.next = next;
		}
		
		public Node(E e) {
			this(e, null);
		}
		
		public Node() {
			this(null, null);
		}
		
		@Override
		public String toString() {
			return e.toString();
		}
	}

	private Node head;
	private int size;

	//构造方法
	public LinkedList() {
		head = null;
		size = 0;
	}

	//获取链表中元素个数
	public int getSize() {
		return size;
	}

	//判断链表是否为空
	public boolean isEmpty() {
		return size==0;
	}

	//在链表头部添加元素
	public void addFirst(E e) {
		/*Node node = new Node(e);
		node.next = head;
		head =node;*/
		head = new Node(e, head); //一行代码更优雅
		size++;
	}
	
	//在链表中间添加元素,在'索引'为index的时候添加元素e
	public void add(int index,E e) {
		if(index &lt; 0 || index &gt;size)
			throw new IllegalArgumentException(&quot;Add failed. Illegal index.&quot;);
		
		if(index == 0)
			addFirst(e);
		else{	
			Node prev = head;
			for(int i=0; i&lt;index-1; i++) 
				prev = prev.next;
			/*Node node = new Node(e);
			node.next = prev.next;
			prev.next = node;*/
			prev.next = new Node(e, prev.next); //同样比较轻便
			size++;
		
		} 
	}		
	
	 //向链表尾部添加元素
	public void addLast(E e) {
		add(size, e);
	}

}
</code></pre>
<p>写到这里, 我便感觉有点不对, 虽然说实际中对链表的操作不会从中间元素开刀, 但是对于我们梳理学习链表知识, 缺需要练习对中间元素的操作, 以便深入理解链表. 从上面的add操作 可以看出, 这样写的话, 需要判断的内容甚多, 尤其在表头前添加元素时, 由于没有前驱, 需要另行编写代码, 比较繁琐. 于是为了统一操作, 我们设立一个虚拟头结点放在表头元素的前面, 该虚拟头结点不存放任何数据, 只起辅助作用.这样会方便很多, 于是 重来一遍!😂<br>
**先声明：一下中的index指的时用户眼中的index,用户 并不知道有虚拟头节点，且数据位置从0开始计数！</p>
<pre><code class="language-java">public class LinkedList改进&lt;E&gt; {
	private class Node{
		public E e;
		public Node next;
		
		public Node(E e, Node next) {
			this.e = e;
			this.next = next;
		}
		
		public Node(E e) {
			this(e, null);
		}
		
		public Node() {
			this(null, null);
		}
		
		@Override
		public String toString() {
			return e.toString();
		}
	}

	private Node dummyHead;
	private int size;
	
	//构造方法
	public LinkedList改进() {
		dummyHead = new Node(null, null); //采用虚拟头结点
		size = 0;
	}
	
	//获取链表中元素个数 O(1)
	public int getSize() {
			return size;
		}

	//判断链表是否为空 O(1)
	public boolean isEmpty() {
		return size==0;
	}

	//向链表中index位置(从0开始),添加元素e O(1/2n)=O(n)
	public void add(int index, E e) {
		//1.判断index是否合法, 不合法抛出异常
		if(index &lt; 0 || index &gt; size)
			throw new IllegalArgumentException(&quot;Add Failed. Illegal index.&quot;);
		//2.添加元素,有了虚拟头结点不用担心0位置的元素没有前驱
		Node pre = dummyHead;
		for(int i=0; i&lt;index ;i++) 
			pre = pre.next;
		//3.此时pre中存放的便是待放入元素e的前驱节点
		//Node node = new Node(e);
		//node.next = pre.next;
		//pre.next = node;
		//上面的步骤3可简化为一句,显得优雅轻便
		 pre.next = new Node(e, pre.next);
		//4.此时元素已经进入链表, 我们需要维护一下size变量
		size++;
		//O(1/2n)=O(n)
	}
	
	//借助add操作完成向表头添加元素的位置  O(1)
	public void addFirst(E e) {
		add(0,e);  //O(1)
	}
	
	//向链表尾部添加元素e  O(n)
	public void addLast(E e) {
		add(size, e);   //O(n)
	}
	
	//获取index位置的元素, 这里的index是用户层面的  O(n)
	public E get(int index) {
		if(index &lt; 0 || index &gt; size)
			throw new IllegalArgumentException(&quot;get Failed. Illegal index.&quot;);
		
		Node cur = dummyHead.next;
		for(int i=0; i&lt;index; i++) 
			cur = cur.next;
		return cur.e;
	}
	
	//获取第一个元素  O(1)
	public E getFist() {
		return get(0);
	}
	
	//获取最后一个元素  O(n)
	public E getLast() {
		return get(size-1);
	}
	
	//修改链表中的第index个位置的元素为e  O(n)
	//在链表中不是一个常用操作, 练习用
	public void set(int index, E e) {
		//1.惯例先判断index是否合法
		if(index &lt; 0 || index &gt; size)
			throw new IllegalArgumentException(&quot;Set Failed. Illegal index.&quot;);
		//2.确定index位置元素节点
		Node cur = dummyHead.next;
		for(int i=0; i&lt;index ;i++)
			cur = cur.next;
		cur.e = e;
	}
	
	//修改表头元素
	public void setFirst(E e) {
		set(0, e);
	}
	
	//查找链表中是否存在元素e  O(n)
	public boolean contains(E e) {
		Node cur = dummyHead.next;
		while(cur != null) {
			if(cur.equals(e))
				return true;
			cur = cur.next;
		}
		return false;
	}
	
	@Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		
		/*Node cur = dummyHead.next;
		while(cur != null) {
			res.append(cur + &quot;-&gt;&quot;);
			cur = cur.next;
		}*/
		for(Node cur = dummyHead.next ; cur != null ; cur = cur.next)
			res.append(cur + &quot;-&gt;&quot;);
		res.append(&quot;NULL&quot;);  //与上面的遍历方式作用相同
		
		return res.toString();
	}
	
	//从链表中删除index位置的元素, 并返回删除元素  O(n)
	//在链表中并不是一个常用的操作, 练习用
	public E remove(int index) {
		
		//1.老规矩, 先判断index是否合法
		if(index &lt; 0 || index &gt; size)
			throw new IllegalArgumentException(&quot;Remove Failed. Illegal index.&quot;);
		//2.找到要删除节点的前驱节点
		Node prev = dummyHead;
		for(int i=0; i&lt;index; i++)
			prev = prev.next;
		//3.找到待删除的节点,并确定返回值
		Node dele = dummyHead.next;
		for(int i=0; i&lt;index; i++)
			dele = dele.next;
		E ret = dele.e;
		//4.执行删除操作
		prev.next = dele.next;
		dele.next = null;
		//5.维护size变量
		size--;
		return ret;
		//O(1/2n)=O(n)
	}
	
	//删除第一个元素  O(1)
	public E removeFirst() {
		return remove(0);  //O(1)
	}
	
	//删除最后一个元素  O(n)
	public E removeLast() {
		return remove(size-1);   //O(n)
	}
	
	
}
</code></pre>
<p>验证一下吧</p>
<pre><code class="language-java">	public static void main(String[] args) {
		// TODO Auto-generated method stub
		LinkedList改进&lt;Integer&gt; linkedlist= new LinkedList改进&lt;&gt;();
		
		for(int i=0; i&lt;5;i++) {
			linkedlist.addFirst(i);
			System.out.println(linkedlist);
		}
		
		linkedlist.add(2, 666);
		System.out.println(&quot;After Add:&quot;);
		System.out.println(linkedlist);
		
		linkedlist.remove(2);
		System.out.println(&quot;After remove:&quot;);
		System.out.println(linkedlist);
		linkedlist.removeFirst();
		System.out.println(&quot;After removeFirst:&quot;);
		System.out.println(linkedlist);
		linkedlist.removeLast();
		System.out.println(&quot;After removeLast:&quot;);
		System.out.println(linkedlist);
	}
</code></pre>
<p>效果如下：</p>
<pre><code class="language-java">0-&gt;NULL
1-&gt;0-&gt;NULL
2-&gt;1-&gt;0-&gt;NULL
3-&gt;2-&gt;1-&gt;0-&gt;NULL
4-&gt;3-&gt;2-&gt;1-&gt;0-&gt;NULL
After Add:
4-&gt;3-&gt;666-&gt;2-&gt;1-&gt;0-&gt;NULL
After remove:
4-&gt;3-&gt;2-&gt;1-&gt;0-&gt;NULL
After removeFirst:
3-&gt;2-&gt;1-&gt;0-&gt;NULL
After removeLast:
3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<h2 id="2分析">2.分析</h2>
<p>至此，我们已经大致实现了链表，在编写过程中有这么几点需要注意：</p>
<ul>
<li>由于虚拟头节点的引入，在遍历链表的时候要注意循环条件，必要时需画图验证。</li>
<li>找index位置节点的前驱时，从dummyHead出发遍历index次，即可到前驱</li>
<li>找index位置的节点时，比如contains操作，从dummHead.next开始遍历index次到达。</li>
</ul>
<p>分析我们实现的链表各项操作的复杂度：</p>
<table>
<thead>
<tr>
<th>method</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>add</td>
<td>O(n)</td>
</tr>
<tr>
<td>addFirst</td>
<td>O(1)</td>
</tr>
<tr>
<td>addLast</td>
<td>O(n)</td>
</tr>
<tr>
<td>remove</td>
<td>O(n)</td>
</tr>
<tr>
<td>removeFirst</td>
<td>O(1)</td>
</tr>
<tr>
<td>removeLast</td>
<td>O(n)</td>
</tr>
<tr>
<td>set</td>
<td>O(n)</td>
</tr>
<tr>
<td>setFirst</td>
<td>O(1)</td>
</tr>
<tr>
<td>contains</td>
<td>O(n)</td>
</tr>
<tr>
<td>get</td>
<td>O(n)</td>
</tr>
<tr>
<td>getFirst</td>
<td>O(1)</td>
</tr>
<tr>
<td>getLast</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<h2 id="3拓展1">3.拓展1</h2>
<p>这里有个有意思的点 ，对于链表来说, 只有头结点的增删查操作是O(1), 非常快,想到了什么😂<br>
这恰恰是我们的栈所需要的结构啊！<br>
不用链表实现一下栈对不起我这一顿分析啊哈哈🙋‍♂️<br>
开搞！<br>
继续实现Stack接口，这时，你就要禁不住赞叹，多态大法好哇！😎</p>
<pre><code class="language-java">public class LinkedListStack&lt;E&gt; implements Stack&lt;E&gt; {
	
	private LinkedList改进&lt;E&gt; list;
	
	public LinkedListStack() {
		list = new LinkedList改进(); 
	}

	@Override
	public int getSize() {
		// TODO Auto-generated method stub
		return list.getSize();
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return list.isEmpty();
	}

	@Override
	public void push(E e) {
		// TODO Auto-generated method stub
		list.addFirst(e);
	}

	@Override
	public E pop() {
		// TODO Auto-generated method stub
		return list.removeFirst();
	}

	@Override
	public E peek() {
		// TODO Auto-generated method stub
		return list.getFist();
	}
	
	@Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		res.append(&quot;LinkedListStack: Top &quot;);
		res.append(list);
		return res.toString();
	}	
}
</code></pre>
<p>加一个main函数验证一下：</p>
<pre><code class="language-java">	public static void main(String[] args) {
		LinkedListStack&lt;Integer&gt; stack = new LinkedListStack&lt;&gt;();
		for(int i=0;i&lt;5;i++) {
			stack.push(i);
			System.out.println(stack);
		}
		stack.pop();
		System.out.println(stack);
	}
</code></pre>
<p>上效果</p>
<pre><code class="language-java">LinkedListStack: Top 0-&gt;NULL
LinkedListStack: Top 1-&gt;0-&gt;NULL
LinkedListStack: Top 2-&gt;1-&gt;0-&gt;NULL
LinkedListStack: Top 3-&gt;2-&gt;1-&gt;0-&gt;NULL
LinkedListStack: Top 4-&gt;3-&gt;2-&gt;1-&gt;0-&gt;NULL
LinkedListStack: Top 3-&gt;2-&gt;1-&gt;0-&gt;NULL
</code></pre>
<p>到这里用链表实现了栈,主要是对表头元素的增删查复杂度为O(1)的特点很适合栈。<br>
现在我们有了两种栈的实现方式，究竟哪一种性能好呢？来比比看啊</p>
<pre><code class="language-java">import java.util.Random;


public class Compare {

    // 测试使用stack运行opCount个push和pop操作所需要的时间，单位：秒
    private static double testStack(Stack&lt;Integer&gt; stack, int opCount){

        long startTime = System.nanoTime();

        Random random = new Random();
        for(int i = 0 ; i &lt; opCount ; i ++)
            stack.push(random.nextInt(Integer.MAX_VALUE));
        for(int i = 0 ; i &lt; opCount ; i ++)
            stack.pop();

        long endTime = System.nanoTime();

        return (endTime - startTime) / 1000000000.0;
    }

    public static void main(String[] args) {

        int opCount = 100000;

        ArrayStack&lt;Integer&gt; arrayStack = new ArrayStack&lt;&gt;();
        double time1 = testStack(arrayStack, opCount);
        System.out.println(&quot;ArrayStack, time: &quot; + time1 + &quot; s&quot;);

        LinkedListStack&lt;Integer&gt; linkedListStack = new LinkedListStack&lt;&gt;();
        double time2 = testStack(linkedListStack, opCount);
        System.out.println(&quot;LinkedListStack, time: &quot; + time2 + &quot; s&quot;);

        // 其实这个时间比较很复杂，因为LinkedListStack中包含更多的new操作
    }
}
</code></pre>
<p>具体比较下来也很客观, 在元素数量不是很大的时候链表栈性能要优于之前以动态数组为底层的栈, 这是因为动态数组中会时不时的进行resize操作, 当然如果元素数量巨大的时候（一千万）, 链表栈也会比动态数组栈要慢 一点, 究其原因 可能是由于链表内部有大量节点导致存在大量的new操作,使其变慢. 但是总体来讲这两种栈的时间复杂度是相同的, 虽然由于外部原因可能会存在一些性能差异, 但这些差异始终较小, 差不了多少.👌</p>
<h2 id="4拓展2">4.拓展2</h2>
<p>栈也搞完了， 同样的我们也可以拿链表来实现队列，为了实现以链表为底层的队列, 我们需要考虑几个问题, 对于链表来说, 只对表头元素进行增删查才可以实现<br>
O(1)的复杂度, 但是对于队列来说, dequeue操作需要出队操作, 不能只操作一端, 需涉及到表尾元素 这样复杂度就不是O(1)了, 如何解决? 回想在依托动态数组实现队列的时候也遇到了相应的问题, 我们的解决方案是添加了tail这一成员变量,专门记录队尾元素的位置, 同理我们也可以在链表中添加一个 tail节点用于记录表尾节点,这样对表尾的插入元素就会容易点. 还有一个问题, 我们要选用链表的哪一端进行入队操作呢? 就上面的复杂度分析来看, 对表头元素的增删都是O(1), 而对于表尾元素<br>
增是O(1), 删的话就麻烦一点, 因为我们还需要表尾元素的前驱节点. 分析下来, 结果就很显然了用表头做队首, 用表尾做队尾, 新增tail节点管理表尾位置, 复杂度为O(1), 而且因为队列不涉及对中间元素的操作,就不需要再用虚拟头结点了。</p>
<p>理清思路之后， 开始coding！💨<br>
同样，我们直接去实现Queue接口。</p>
<pre><code class="language-java">public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; {
   
   private class Node{
   	public E e;
   	public Node next;
   	
   	public Node(E e, Node next) {
   		this.e = e;
   		this.next = next;
   	}
   	
   	public Node(E e) {
   		this(e, null);
   	}
   	
   	public Node() {
   		this(null, null);
   	}
   	
   	@Override
   	public String toString() {
   		return e.toString();
   	}
   }

   private Node head;
   private Node tail;
   private int size;
   
   public LinkedListQueue() {
   	head = null;
   	tail = null;
   	size = 0;
   }

   @Override
   public int getSize() {
   	// TODO Auto-generated method stub
   	return size;
   }

   @Override
   public boolean isEmpty() {
   	// TODO Auto-generated method stub
   	return size==0;
   }

   @Override
   public void enqueue(E e) {
   	// TODO Auto-generated method stub
   	//1.判断此时队列是否为空
   	if(tail == null) {
   		tail = new Node(e);
   		head = tail;
   	}
   	else {
   		tail.next = new Node(e);
   		tail = tail.next;
   	}
   	size++;
   }

   @Override
   public E dequeue() {
   	// TODO Auto-generated method stub
   	if(isEmpty())
   		throw new IllegalArgumentException(&quot;Dequeue Failed. Queue is empty.&quot;);
   	Node ret = head;
   	head = head.next;
   	ret.next = null;
   	if(head == null)
   		tail = null;
   	size--;
   	return ret.e;
   }

   @Override
   public E getFront() {
   	// TODO Auto-generated method stub
   	return head.e;
   }
   
   public String toString() {
   	StringBuilder res = new StringBuilder();
   	res.append(&quot;LinkedListQueue: Front &quot;);
   	Node node = head;
   	while(node != null) {
   		res.append(node+&quot;-&gt;&quot;);
   		node = node.next;
   	}
   	res.append(&quot;NULL Tail&quot;);
   	return res.toString();
   }
}
</code></pre>
<p>ok，主体已经写完，加个main函数看看效果。</p>
<pre><code class="language-java">	public static void main(String[] args) {
   	LinkedListQueue&lt;Integer&gt; queue = new LinkedListQueue&lt;&gt;();
   	for(int i=0;i&lt;10;i++) {
   		queue.enqueue(i);
   		System.out.println(queue);
   		System.out.println();
   		if(i%3 == 2) {
   			queue.dequeue();
   			System.out.println(queue);
   			System.out.println();
   		}
   	}
   }
</code></pre>
<p>结果如下</p>
<pre><code class="language-java">LinkedListQueue: Front 0-&gt;NULL Tail

LinkedListQueue: Front 0-&gt;1-&gt;NULL Tail

LinkedListQueue: Front 0-&gt;1-&gt;2-&gt;NULL Tail

LinkedListQueue: Front 1-&gt;2-&gt;NULL Tail

LinkedListQueue: Front 1-&gt;2-&gt;3-&gt;NULL Tail

LinkedListQueue: Front 1-&gt;2-&gt;3-&gt;4-&gt;NULL Tail

LinkedListQueue: Front 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL Tail

LinkedListQueue: Front 2-&gt;3-&gt;4-&gt;5-&gt;NULL Tail

LinkedListQueue: Front 2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;NULL Tail

LinkedListQueue: Front 2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;NULL Tail

LinkedListQueue: Front 2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL Tail

LinkedListQueue: Front 3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;NULL Tail

LinkedListQueue: Front 3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9-&gt;NULL Tail
</code></pre>
<p>现在我们有三种可以实现队列的方法了，分别是ArrayQueue, LoopQueue, LinkedListQueue. 现在来比较一下他们的性能吧！</p>
<pre><code class="language-java">public class Main {
		// 测试使用q运行opCount个enqueueu和dequeue操作所需要的时间，单位：秒
	    private static double testQueue(Queue&lt;Integer&gt; q, int opCount){

	        long startTime = System.nanoTime();

	        Random random = new Random();
	        for(int i = 0 ; i &lt; opCount ; i ++)
	            q.enqueue(random.nextInt(Integer.MAX_VALUE));
	        for(int i = 0 ; i &lt; opCount ; i ++)
	            q.dequeue();

	        long endTime = System.nanoTime();

	        return (endTime - startTime) / 1000000000.0;
	    }

	    public static void main(String[] args) {

	        int opCount = 100000;

	        ArrayQueue&lt;Integer&gt; arrayQueue = new ArrayQueue&lt;&gt;();
	        double time1 = testQueue(arrayQueue, opCount);
	        System.out.println(&quot;ArrayQueue, time: &quot; + time1 + &quot; s&quot;);

	        LoopQueue&lt;Integer&gt; loopQueue = new LoopQueue&lt;&gt;();
	        double time2 = testQueue(loopQueue, opCount);
	        System.out.println(&quot;LoopQueue, time: &quot; + time2 + &quot; s&quot;);
	        
	        LinkedListQueue&lt;Integer&gt; LinkedQueue = new LinkedListQueue&lt;&gt;();
	        double time3 = testQueue(LinkedQueue, opCount);
	        System.out.println(&quot;LinkedQueue, time: &quot; + time3 + &quot; s&quot;);
	}

}
</code></pre>
<p><strong>一起来看看结果叭</strong></p>
<pre><code class="language-java">ArrayQueue, time: 49.172133193 s
LoopQueue, time: 0.013723476 s
LinkedQueue, time: 0.008158352 s
</code></pre>
<br>
<p>这就是数据结构充满魅力的地方叭，一步步去探索最优解法，不断锻炼思维能力才是我们的终极目标鸭😄</p>
<br>
<p><strong>今天就到这里了嗷~</strong></p>
<hr>
<br>  
<p><strong>推荐阅读</strong><br>
<a href="http://stevenhy.com/post/9KuaIONib">LeetCode203 - 链表移除问题的三种解决方案</a><br>
<a href="http://stevenhy.com/post/9KuaIONib1">深入理解递归的运行机制</a><br>
<a href="http://stevenhy.com/post/sjjghg-zddcsx/">数据结构回顾-栈的底层实现</a><br>
<a href="http://stevenhy.com/post/RPOfy91HP/">数据结构回顾-队列的实现与优化</a><br>
<br></p>
<hr>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/FiTjgJh8i/">http://stevenhy.com/post/FiTjgJh8i/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构回顾 - 队列的实现与优化]]></title>
        <id>http://stevenhy.com/post/RPOfy91HP</id>
        <link href="http://stevenhy.com/post/RPOfy91HP">
        </link>
        <updated>2019-08-12T12:40:31.000Z</updated>
        <summary type="html"><![CDATA[<p>之前我们实现了一个栈，栈是一种先进后出的数据结构(FILO), 那么在数据结构中还有一种先进先出的数据结构(FIFO)与之对应, 即队列, 今天我们一步步实现自己的队列并优化它!</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前我们实现了一个栈，栈是一种先进后出的数据结构(FILO), 那么在数据结构中还有一种先进先出的数据结构(FIFO)与之对应, 即队列, 今天我们一步步实现自己的队列并优化它!</p>
<!-- more -->
<h2 id="1需求分析">1.需求分析</h2>
<p>同样的我们在实现一个队列之前, 要搞清楚它要包含些什么功能, 同样的为了使队列支持多态性, 我们先定义一个接口<code>Queue</code>, 理清我们具体要实现的方法.</p>
<pre><code class="language-java">public interface Queue&lt;E&gt; {
	int getSize();       //获取队列中的元素个数
	boolean isEmpty();   //判断队列是否为空
	void enqueue(E e);    //入队
	E dequeue();             //出队
	E getFront();            //获取对首元素
}
</code></pre>
<p>明确目标之后我们开始编写具体的实现代码</p>
<h2 id="2编写">2.编写</h2>
<p>我们要编写的类为<code>ArrayQueue</code> , 并实现Queue接口.</p>
<pre><code class="language-java">publice class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; {
	//依然以我们之前创建的Array作为底层
	//这里的array是不需要用户看见的,用private关键字
	private Array&lt;E&gt; array; 

	//当用户知道具体容量时,提供有参构造方法
	public ArrayQueue(int capacity) {
		array = new Array&lt;&gt;(capacity);
	}

	//当用户不知道具体容量时,提供无参构造方法
	public ArrayQueue() {
		array = new Array&lt;&gt;(); 
	}
	
	@Override
	public int getSize() {
		// TODO Auto-generated method stub
		return array.getSize();
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return array.isEmpty();
	}

	@Override
	public void enqueue(E e) {
		// TODO Auto-generated method stub
		array.addlast(e);
	}

	@Override
	public E dequeue() {
		// TODO Auto-generated method stub
		return array.removeFirst(); //除该操作的复杂度是O(n), 其余都是O(1), 要解决用循环队列, 后面会优化
	}

	@Override
	public E getFront() {
		// TODO Auto-generated method stub
		return array.getFirst();
	}
	
	@Override
	public String toString(){	
		StringBuilder res = new StringBuilder();
		res.append(&quot;Queue: &quot;);
		res.append(&quot;Front [&quot;);
		for(int i=0;i&lt;array.getSize();i++) {
			res.append(array.get(i));
			if(i != array.getSize() - 1)
				res.append(&quot;, &quot;);
		}
		res.append(&quot;] tail&quot;);
		return res.toString();
	}
}
</code></pre>
<p>我们先来简单测试一下, 编写一个main方法如下:</p>
<pre><code class="language-java">public class Main {
		// TODO Auto-generated method stub
	public static void main(String[] args) {
		ArrayQueue&lt;Integer&gt; queue = new ArrayQueue&lt;&gt;();
		for(int i=0;i&lt;10;i++) {
			queue.enqueue(i);
			System.out.println(queue);
			//每隔三次出一次队
			if(i%3 == 2) {
				queue.dequeue();
				System.out.println(queue);
			}
		}
	}
}
</code></pre>
<p>结果如下</p>
<pre><code class="language-java">Queue: Front [0] tail
Queue: Front [0, 1] tail
Queue: Front [0, 1, 2] tail
Queue: Front [1, 2] tail
Queue: Front [1, 2, 3] tail
Queue: Front [1, 2, 3, 4] tail
Queue: Front [1, 2, 3, 4, 5] tail
Queue: Front [2, 3, 4, 5] tail
Queue: Front [2, 3, 4, 5, 6] tail
Queue: Front [2, 3, 4, 5, 6, 7] tail
Queue: Front [2, 3, 4, 5, 6, 7, 8] tail
Queue: Front [3, 4, 5, 6, 7, 8] tail
Queue: Front [3, 4, 5, 6, 7, 8, 9] tail
</code></pre>
<h2 id="3复杂度分析及优化方向">3.复杂度分析及优化方向</h2>
<p>我们来先来分析上面编写的<code>ArrayQueue</code>的各项操作的复杂度, 如下所示</p>
<table>
<thead>
<tr>
<th>method</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>getSize()</td>
<td>O(1)</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>O(1)</td>
</tr>
<tr>
<td>enqueue(E e)</td>
<td>O(1)  (均摊)</td>
</tr>
<tr>
<td>getFront()</td>
<td>O(1)</td>
</tr>
<tr>
<td>dequeue()</td>
<td>O(n)</td>
</tr>
</tbody>
</table>
<p>可以看出上面的操作, 除了<code>dequeue()</code>方法的复杂度是O(n)外, 其余方法复杂度均为O(1).<br>
这也就是我们的优化方向, 能不能把<code>dequeue()</code>操作的时间复杂度也降低到O(1)呢?<br>
答案是肯定的, 至于怎么解决, 我们现在一步步来分析<br>
首先, <code>dequeue()</code>的时间复杂度为O(n)的原因在于, 每次对队首元素进行出队操作时, 要对剩下的所有元素向前移动一位,  这对于我们的动态数组来说是必要的, 因为我们需要<code>size</code>来统计当前数组中的元素个数, size所存的永远是第一个空位置, 那么如果不移动, size的值就会不稳定, 无法准确得到数组元素个数, 即使可以得到,也不好维护.<br>
那么对于一个队列来讲, 是否一定要移动后面的元素呢? 大可不必! 从用户角度来想, 队列维护的是出队及入队序列, 我们只需要让元素保持一定的顺序即可, 不必强求对首必须在索引为0的位置上, 这样一来, 我们就得到了一种新的队列 <strong><code>循环队列</code></strong>, 元素不再移动之后, 复杂度即变为O(1).<br>
光说不练假把式, 我们来通过代码具体实现:<br>
还是实现之前定义的队列<code>Queue</code>接口, 此处便体会到, 多态设计模式的好处😁</p>
<pre><code class="language-java">public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; {
	
	private E[] data; //不在依赖原先的动态数组
	private int front, tail;
	private int size;
	
	//由于实际可存元素数量比数组长度少1, 故要容纳capacity个元素, 长度需为capacity+1
	public LoopQueue(int capacity) {
		data = (E[])new Object[capacity + 1];
		front = 0;
		tail = 0;
		size = 0;
	}
	
	public LoopQueue() {
		this(10);
	}
	
	public int getCapacity() {
		return data.length-1;
	}
	
	@Override
	public int getSize() {
		// TODO Auto-generated method stub
		return size;
	}

	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return front == tail;
	}

	//循环队列, 相应的逻辑要改变
	@Override
	public void enqueue(E e) {
		// TODO Auto-generated method stub
		int c = data.length;
		if((tail+1)%c == front)
			resize(getCapacity() * 2);
		data[tail] = e;
		tail = (tail + 1)% (data.length);
		size++;
		
	}

	//定义变容操作,道理同动态数组
	private void resize(int newCapacity) {
		// TODO Auto-generated method stub
		E[] newData = (E[])new Object[newCapacity+1];
		for(int i=0; i&lt;size ; i++)
			newData[i] = data[(i+front)%data.length];
		
		data = newData;
		front = 0;
		tail = size;
	}

	@Override
	public E dequeue() {
		// TODO Auto-generated method stub
		if(isEmpty())
			throw new IllegalArgumentException(&quot;Cannot dequeue from an empty queue!&quot;);
		E element = data[front];
		data[front] = null;
		front = (front+1)%data.length;
		size--;
		if(size == getCapacity()/4 &amp;&amp; getCapacity()/2!=0)
			resize(getCapacity()/2);
		return element;
	}

	@Override
	public E getFront() {
		// TODO Auto-generated method stub
		if(isEmpty())
			throw new IllegalArgumentException(&quot;Cannot getFront from an empty queue!&quot;);
		return data[front];
	}

	@Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		res.append(String.format(&quot;Queue: size = %d, capacity = %d\n&quot;,size, getCapacity()));
		res.append(&quot;front [&quot;);
		//两种遍历循环队列的方式, 另一种看resize中的遍历
		for(int i=front;i != tail; i = (i+1)%data.length) {
			res.append(data[i]);
			if((i +1)%data.length != tail)
				res.append(&quot;, &quot;);
		}
		res.append(&quot;] tail&quot;);
		return res.toString();
	}
}
</code></pre>
<p>同样,我们来验证一下,看看具体效果:</p>
<pre><code class="language-java">public class Main {
		// TODO Auto-generated method stub
	public static void main(String[] args) {
		LoopQueue&lt;Integer&gt; queue = new LoopQueue&lt;&gt;();
		for(int i=0;i&lt;10;i++) {
			queue.enqueue(i);
			System.out.println(queue);
			System.out.println();
			if(i%3 == 2) {
				queue.dequeue();
				System.out.println(queue);
				System.out.println();
			}
		}
	}
}
</code></pre>
<p><strong>效果如下</strong></p>
<pre><code class="language-java">Queue: size = 1, capacity = 10
front [0] tail

Queue: size = 2, capacity = 10
front [0, 1] tail

Queue: size = 3, capacity = 10
front [0, 1, 2] tail

Queue: size = 2, capacity = 5
front [1, 2] tail

Queue: size = 3, capacity = 5
front [1, 2, 3] tail

Queue: size = 4, capacity = 5
front [1, 2, 3, 4] tail

Queue: size = 5, capacity = 5
front [1, 2, 3, 4, 5] tail

Queue: size = 4, capacity = 5
front [2, 3, 4, 5] tail

Queue: size = 5, capacity = 5
front [2, 3, 4, 5, 6] tail

Queue: size = 6, capacity = 10
front [2, 3, 4, 5, 6, 7] tail

Queue: size = 7, capacity = 10
front [2, 3, 4, 5, 6, 7, 8] tail

Queue: size = 6, capacity = 10
front [3, 4, 5, 6, 7, 8] tail

Queue: size = 7, capacity = 10
front [3, 4, 5, 6, 7, 8, 9] tail
</code></pre>
<h2 id="优化总结">优化总结</h2>
<p>经优化, 将队列变为循环队列后, 我们再来看看时间复杂度:</p>
<table>
<thead>
<tr>
<th>method</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>getCapacity()</td>
<td>O(1)</td>
</tr>
<tr>
<td>getSize()</td>
<td>O(1)</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>O(1)</td>
</tr>
<tr>
<td>enqueue(E e)</td>
<td>O(1) (均摊)</td>
</tr>
<tr>
<td>dequeue()</td>
<td>O(1) (均摊)</td>
</tr>
</tbody>
</table>
<p>至此优化完成, 其实在上面实现循环队列的时候, 不用size成员变量也可实现所有功能, 大小则通过front和tail两个变量来计算, 需要考虑的方面还挺多, 姑且当做一个作业去做,锻炼能力, 等实现了在贴出来与各位交流!</p>
<hr>
<br>
<p><strong>推荐阅读</strong><br>
<a href="http://stevenhy.com/post/FiTjgJh8i">数据结构回顾 - 链表实现及应用</a><br>
<a href="http://stevenhy.com/post/sjjghg-zddcsx">数据结构回顾 - 栈的底层实现</a><br>
<br></p>
<hr>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/RPOfy91HP/">http://stevenhy.com/post/RPOfy91HP/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构回顾 - 栈的底层实现]]></title>
        <id>http://stevenhy.com/post/sjjghg-zddcsx</id>
        <link href="http://stevenhy.com/post/sjjghg-zddcsx">
        </link>
        <updated>2019-08-12T09:48:39.000Z</updated>
        <summary type="html"><![CDATA[<p>🙎‍♂️💦之前在博客中, 从0实现了动态数组, 这个数组灵活性相当高, 在容量不够或者容量过大时都会进行<code>resize</code>操作, 且这个动态数组支持泛型, 任何对象都可以成为其元素。<br>
这次，我们依然自己来实现一个栈！</p>
]]></summary>
        <content type="html"><![CDATA[<p>🙎‍♂️💦之前在博客中, 从0实现了动态数组, 这个数组灵活性相当高, 在容量不够或者容量过大时都会进行<code>resize</code>操作, 且这个动态数组支持泛型, 任何对象都可以成为其元素。<br>
这次，我们依然自己来实现一个栈！</p>
<!-- more -->
<p>栈在学习过程中出现频率挺高， 举两个例子，第一个是撤销操作，就是我们在文本编辑器中常用到的撤销(Undo)操作，原理和栈是一个道理，还有一个是程序调用的系统栈，在对子过程进行调用的时候，会把主函数中子函数的入口地址存入栈中，待子过程调用完毕后，会从该系统栈中取出主函数中的位置，接着执行剩余的命令。</p>
<p>现在，我们来想一想该如何实现这个栈。🧐</p>
<h2 id="1需求分析">1.需求分析</h2>
<p>首先，我们把栈要实现的功能进行罗列：</p>
<pre><code class="language-java">	void push(E)    //进栈
	E pop()            //出栈
	E peek()          //查看栈顶元素
	int getSize()    //获取栈中元素个数
	boolean isEmpty()   //查看栈是否非空
</code></pre>
<p>以上就是我们在栈中要实现的功能，从用户角度来看，设计的栈支持这些操作就好，具体底层的实现，用户并不需要关心，底层实现有多种方式，为满足多态性要求，我们先设置一个<code>Stack</code>接口，定义出基本的操作， 然后我们可以利用以实现的动态数组，来构建自己的<code>ArrayStack</code>类，使其实现<code>Stack</code>接口，这样我们的栈也有了类似动态数组的自动调整容量的<code>resize()</code>方法。</p>
<h2 id="2具体实现">2.具体实现</h2>
<p><strong>Stack 接口定义如下</strong></p>
<pre><code class="language-java">public interface Stack&lt;E&gt; {
    int getSize();
    boolean isEmpty();
    void push(E e);
    E pop();
    E peek();
}
</code></pre>
<p><strong>ArrayStack 定义如下</strong></p>
<pre><code class="language-java">public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; {

	Array&lt;E&gt; array;
	
	//构造方法用于用户事先知道容量
	public ArrayStack(int capacity) {
		array = new Array&lt;&gt;(capacity);
	}
	//当用户不确定所需容量，提供无参构造函数
	public ArrayStack() {
		array = new Array&lt;&gt;();
	}
	
	
	@Override
	public int getSize() {
		// TODO Auto-generated method stub
		return array.getSize();
	}
	
	@Override
	public boolean isEmpty() {
		// TODO Auto-generated method stub
		return array.isEmpty();
	}

	public int getCapacity() {
		return array.getCapiticy();
	}
	
	@Override
	public E pop() {
		// TODO Auto-generated method stub
		return array.removeLast();
	}

	@Override
	public E peek() {
		// TODO Auto-generated method stub
		return array.getLast(); // 为方便，在Array类中添加了getLast()方法 
	}
	
	@Override
	public void push(E e) {
		// TODO Auto-generated method stub
		array.addlast(e); //时间复杂度复习中, 因为与动态数组一样要考虑到resize操作, 故用均摊法分析复杂度为O(1)
	}
	
	@Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		res.append(&quot;Stack: [&quot;);
		//res.append(array.toString());
		for(int i=0; i&lt;array.getSize(); i++) {
			res.append(array.get(i));
			if(i != array.getSize()-1)
				res.append(',');
		}
		res.append(&quot;] top&quot;);
		return res.toString();
	}
	
	
}
</code></pre>
<p>这样我们的栈就定义好了。</p>
<h2 id="3复杂度分析">3.复杂度分析</h2>
<p>接着我们需要分析它各项操作的时间复杂度来大致衡量性能<br>
<strong>ArrayStack</strong></p>
<table>
<thead>
<tr>
<th>method</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>push</td>
<td>O(1)  均摊</td>
</tr>
<tr>
<td>pop</td>
<td>O(1)  均摊</td>
</tr>
<tr>
<td>peek</td>
<td>O(1)</td>
</tr>
<tr>
<td>getSize</td>
<td>O(1)</td>
</tr>
<tr>
<td>isEmpty()</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h2 id="4验证结果">4.验证结果</h2>
<p>编写main方法进行验证，如下：</p>
<pre><code class="language-java">public class Main {
		public static void main(String[] args) {
		ArrayStack&lt;Integer&gt; stack = new ArrayStack&lt;&gt;();
		for(int i=0;i&lt;5;i++) {
			stack.push(i);
			System.out.println(stack);
		}
		stack.pop();
		System.out.println(stack);
		}
}
</code></pre>
<p><strong>结果如下</strong><br>
Stack: [0] top<br>
Stack: [0,1] top<br>
Stack: [0,1,2] top<br>
Stack: [0,1,2,3] top<br>
Stack: [0,1,2,3,4] top<br>
Stack: [0,1,2,3] top<br>
<br></p>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/sjjghg-zddcsx/">http://stevenhy.com/post/sjjghg-zddcsx/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构回顾 - 从0实现动态数组]]></title>
        <id>http://stevenhy.com/post/shu-ju-jie-gou-hui-gu-cong-0-shi-xian-dong-tai-shu-zu</id>
        <link href="http://stevenhy.com/post/shu-ju-jie-gou-hui-gu-cong-0-shi-xian-dong-tai-shu-zu">
        </link>
        <updated>2019-08-11T13:34:53.000Z</updated>
        <summary type="html"><![CDATA[<p>学完数据结构已经一年有余，有好多细节都已经要忘记了，所以开了这么一个系列，对数据结构的基础知识进行回顾<br>
该系列用java语言来进行实现，同时也借此机会巩固一下Java的基础语法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>学完数据结构已经一年有余，有好多细节都已经要忘记了，所以开了这么一个系列，对数据结构的基础知识进行回顾<br>
该系列用java语言来进行实现，同时也借此机会巩固一下Java的基础语法。</p>
<!-- more -->
<h2 id="1-在自主实现一个动态数组之前不妨先来复习java中的数组基础知识">1. 在自主实现一个动态数组之前，不妨先来复习Java中的数组基础知识。</h2>
<p><strong>声明数组变量</strong></p>
<p>在声明数组变量时，Java提供了两种方式:</p>
<pre><code class="language-java">dataType[] arrayname  // java所倡导的方式
dataType arrayname[]  //与上面的方法效果相同,但不建议使用
</code></pre>
<p><strong>创建数组</strong></p>
<pre><code class="language-java">arrayRefVar = new dataType[arraySize];
//上面的语法做了两件事
//1.创建了一个dataType类型的arraySize大小的数组
//2.把这个数组的引用赋值给变量arrayRefVar

//同样的,数组的创建与声明可以用一条语句完成
dataType[] arrayRefVar = new dataType[arraySize];
//也可以用大括号对元素进行初始化
dataType[] arrayRefVar = new dataType[]{1,2,3,4,5};
</code></pre>
<p><strong>遍历数组</strong></p>
<pre><code class="language-java">//第一种遍历方式,for循环
for(int i=0; i&lt;arrayRefVar.length; i++)
      System.out.println(arrayRefVar[i]);
      
//第二种遍历方式
for(dataType element:arrayRefVar)
      System.out.println(arrayRefVar[i]);

</code></pre>
<h2 id="2-借助已有的静态数组自己实现动态数组">2. 借助已有的静态数组自己实现动态数组</h2>
<pre><code class="language-java">//建立一个Array类,作为动态数组类,Array类有两个私有变量,其中data是一个静态数组,
//size种永远存放着数组中第一个空位置, 其大小表示了数组中变量的个数.
//该动态数组支持泛型, 任何对象都可以成为数组成员变量
public class Array&lt;E&gt; {
	private E[] data;
	private int size;
	
	//构造函数，传入数组的容量capacity构造函数
	public Array(int capaticy) {
		data = (E[])new Object[capaticy];
		size = 0;
	}
	
	//无参的构造函数，默认数组的容量capacity=10
	public Array() {
		this(10);
	}
	
	//获取数组中元素的个数
	public int getSize() {
		return size;
	}
	
	//获取数组的容量
	public int getCapiticy() {
		return data.length;
	}
	
	//返回数组是否为空
	public boolean isEmpty() {
		return size == 0;
	}
	
	//向数组末尾添加元素
	public void addlast(E e) {
		
		add(size,e);
	}
	
	//向数组头部添加元素
	public void addFirst(E e) {
		add(0, e);
	}
	
	//再index位置添加一个新元素e
	public void add(int index, E e) {
		
		
		if(!(index&gt;=0 &amp;&amp; index&lt;=size))
			throw new IllegalArgumentException(&quot;Add failed. Require index &gt;=0 and index &lt;=size&quot;);
		
		if(size == data.length)
			//throw new IllegalArgumentException(&quot;AddLast faild. Array is full.&quot;);
			resize(2 * data.length);
		
			
			for(int i = size-1; i&gt;=index; i--)
			data[i+1] = data[i];
		
		data[index] = e;
		size++;
	}
	
	//获取index位置的元素
	E get(int index) {
		if(!(index&gt;=0 &amp;&amp; index&lt;size))
			throw new IllegalArgumentException(&quot;Get failed. Require index &gt;=0 and index &lt;size&quot;);
		
		return data[index];
	}
	
	//修改index位置的元素
	void set(int index, E e) {
		if(!(index&gt;=0 &amp;&amp; index&lt;size))
			throw new IllegalArgumentException(&quot;Set failed. Require index &gt;=0 and index &lt;size&quot;);
		
		data[index] = e;
	}
	
	//查找数组中是否存在元素e
	public boolean contains(E e) {
		for(int i=0; i&lt;size; i++) {
			if(data[i].equals(e))
				return true;
		}
		return false;
	}
	
	//查找元素e在数组中第一次出现的位置,如果e不存在则返回-1
	public int find(E e) {
		for(int i=0; i&lt;size; i++) {
			if(data[i].equals(e))
				return i;
		}
		return -1;
	}
	
	//从数组中删除第一个元素
	public E removeFirst() {
		return remove(0);
	}
	
	//从数组中删除最后一个元素
	public E removeLast() {
		return remove(size-1);
	}
	
	//删除index位置的元素,返回删除元素
	public E remove(int index) {
		if(!(index&gt;=0 &amp;&amp; index&lt;size))
			throw new IllegalArgumentException(&quot;Remove failed. Require index &gt;=0 and index &lt;=size&quot;);
		E ret = data[index];
		for(int i=index; i&lt;size-1 ;i++) {
			data[i] = data[i+1];
		}
		size -=1;
		data[size]=null; // loitering object != memory leak
		
		if(size == data.length / 2)
			resize(data.length / 2);
		
		return ret;
	}
	
	//删除数组中的第一个e元素
	public void removeElement(E e) {
		int index = find(e);
		if(index != -1)
			remove(index);
	}
	
	//删除数组中的所有e元素
	public void removeAllElement(E e) {
		System.out.printf(&quot;size is %d&quot;, size);
		for(int i=0;i&lt;size;i++) {
			if(data[i].equals(e)) {
				remove(i);
				i-=1;
			}
				
		}
	}
	
	@Override
	public String toString() {
		StringBuilder res = new StringBuilder();
		res.append(String.format(&quot;Array: size = %d, capacity = %d\n&quot;,size, data.length));
		res.append('[');
		for(int i=0;i&lt;size;i++) {
			res.append(data[i]);
			if(i != size - 1)
				res.append(&quot;, &quot;);
		}
		res.append(']');
		return res.toString();
	}
	
	//动态变容，用均摊发分析，时间复杂度为O(1)!
	private void resize(int newcapacity) {
		E[] newdata = (E[])new Object[newcapacity];
		for(int i=0;i&lt;size;i++) 
			newdata[i] = data[i];
		data = newdata;
	}
	
	//同时看addLast和removeLast操作，在容量变换点重复操作两个方法，会一直有O(n),出现复杂度震荡
	//原因是由于removeLast操作过于(Eager)着急
	//解决：Lazy
	//当size为capacity的1/4时，缩容1/2；
}
</code></pre>
<p>至此动态数组已经基本搭建完成, 该动态数组的实现了自主扩容, 接下来我们对搭建好的动态数组进行性能分析..</p>
<h2 id="3时间复杂度分析">3.时间复杂度分析</h2>
<p>分析来看, 我们创建的动态数组完成了, 增 删 改 查 , 几类功能, 对于添加功能来看(add系列), 其中的<code>addLast</code>方法如果不考虑<code>resize</code>操作,时间复杂度为O(1), 但是<code>resize</code>操作的时间复杂度是O(n), 所以把<code>addLast</code>方法的时间复杂度记为O(n), 同理删除操作的时间复杂度也为O(n), 对于修改和查询操作,如果已知索引,时间复杂度均是O(1), 如果不知道索引, 那么时间复杂度就是O(n), 因此如果知道索引的话,数组结构的速度是非常快的.</p>
<h2 id="4优化">4.优化</h2>
<p>经过上面的分析, 我们对容量的<code>resize</code>操作好像性能很一般, 果真是这样吗?<br>
其实,我们在上面分析的时候漏掉了一个小细节, 就是<code>addLast</code>和<code>removeLast</code>两个方法不可能每次调用都会触发<code>resize</code>操作, 如果用O(n)来表示<code>resize</code>的时间复杂度, 显然是不合适的.</p>
<p>我们应该采取 <strong>均摊法</strong> 来分析, 如果容量是n, 那么<code>resize</code>会在第 n+1 次操作时触发, 即 n+1 次操作的执行次数是 n+n+1=2n+1 次, 2n+1/n+1 约等于2, 则时间复杂度是O(2)=O(1), 与n是没有关系的, 这样分析下来, <code>resize</code>操作的性能其实是较高的..</p>
<p>等等等等!</p>
<p>也许有细心的朋友已经发现了, 虽说照上面分析是O(1), 但是 我如果不停的触发<code>resize</code>操作的, 即我在一个容量边界不停执行<code>addLast</code> 和 <code>removeLast</code>操作, 那岂不是会一直触发<code>resize</code> 操作, 那么复杂度肯定不是O(1)了, 的确如此, 这样的情况应该考虑, 我们把这种情况称为发生了 <strong>复杂度震荡</strong> !</p>
<p>如何解决呢? 对于<code>addLast</code> 来说, 到了容量边界如果要继续增加元素, 那么扩容是必须的, 否则会抛出异常. 那么对于 <code>removeLast</code> 来说, 当实际需要容量是真实容量的1/2时, 把另一半的容量全部缩减是非必须的, 既然如此, 我们不妨把缩容量操作改为当实际元素个数是容量的1/4时, 在缩到1/2, Lazy 一点, 这样就不会产生 复杂度震荡的问题. 这样的将操作 <strong>Lazy</strong> 化的思路在算法中很常见, 灵活利用 <strong>Lazy</strong>策略, 有时会产生更好的性能!</p>
<pre><code class="language-java">	//删除index位置的元素,返回删除元素
	public E remove(int index) {
		if(!(index&gt;=0 &amp;&amp; index&lt;size))
			throw new IllegalArgumentException(&quot;Remove failed. Require index &gt;=0 and index &lt;=size&quot;);
		E ret = data[index];
		for(int i=index; i&lt;size-1 ;i++) {
			data[i] = data[i+1];
		}
		size -=1;
		data[size]=null; // loitering object != memory leak
            //改进后
		//防止最后缩容时出现size为0的情况，故加一个data.length/2!=0的条件
		if(size == data.length/4 &amp;&amp; data.length / 2 != 0)
			resize(data.length/2);
		
		return ret;
	}
</code></pre>
<br>
<br>
<blockquote>
<p>本文作者: 韩宇<br>
本文链接: <a href="http://stevenhy.com/post/shu-ju-jie-gou-hui-gu-cong-0-shi-xian-dong-tai-shu-zu/">http://stevenhy.com/post/shu-ju-jie-gou-hui-gu-cong-0-shi-xian-dong-tai-shu-zu/</a><br>
版权声明: 本博客所有文章除特别声明外, 均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议, 转载请注明出处</p>
</blockquote>
]]></content>
    </entry>
</feed>